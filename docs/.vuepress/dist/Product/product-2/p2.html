<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>目录结构 | sugarZhai</title>
    <meta name="description" content="share by learning and grow by sharing">
    
    
    <link rel="preload" href="/sugarBlog/assets/css/0.styles.9ba38a1a.css" as="style"><link rel="preload" href="/sugarBlog/assets/js/app.94826577.js" as="script"><link rel="preload" href="/sugarBlog/assets/js/2.baf12719.js" as="script"><link rel="preload" href="/sugarBlog/assets/js/15.33b09ea6.js" as="script"><link rel="prefetch" href="/sugarBlog/assets/js/10.c5e2f0ed.js"><link rel="prefetch" href="/sugarBlog/assets/js/11.2033cb00.js"><link rel="prefetch" href="/sugarBlog/assets/js/12.fc5f4412.js"><link rel="prefetch" href="/sugarBlog/assets/js/13.eaa51b89.js"><link rel="prefetch" href="/sugarBlog/assets/js/14.b4d19b94.js"><link rel="prefetch" href="/sugarBlog/assets/js/16.d5b116df.js"><link rel="prefetch" href="/sugarBlog/assets/js/17.737b7002.js"><link rel="prefetch" href="/sugarBlog/assets/js/3.f3a2b0d2.js"><link rel="prefetch" href="/sugarBlog/assets/js/4.7bf71852.js"><link rel="prefetch" href="/sugarBlog/assets/js/5.84ea8c35.js"><link rel="prefetch" href="/sugarBlog/assets/js/6.23ae280b.js"><link rel="prefetch" href="/sugarBlog/assets/js/7.d3a879df.js"><link rel="prefetch" href="/sugarBlog/assets/js/8.c01e6928.js"><link rel="prefetch" href="/sugarBlog/assets/js/9.958f88f4.js">
    <link rel="stylesheet" href="/sugarBlog/assets/css/0.styles.9ba38a1a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/sugarBlog/" class="home-link router-link-active"><!----> <span class="site-name">sugarZhai</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/sugarBlog/Code/basic.html" class="nav-link">编程指南</a></div><div class="nav-item"><a href="/sugarBlog/Product/" class="nav-link router-link-active">产品初探</a></div><div class="nav-item"><a href="/sugarBlog/Life/" class="nav-link">生活鸡汤</a></div><div class="nav-item"><a href="/sugarBlog/About/" class="nav-link">关于本站</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/sugarBlog/Code/basic.html" class="nav-link">编程指南</a></div><div class="nav-item"><a href="/sugarBlog/Product/" class="nav-link router-link-active">产品初探</a></div><div class="nav-item"><a href="/sugarBlog/Life/" class="nav-link">生活鸡汤</a></div><div class="nav-item"><a href="/sugarBlog/About/" class="nav-link">关于本站</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>产品1</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>产品2</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/sugarBlog/Product/product-2/p2.html" class="active sidebar-link">产品22</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#目录结构" class="sidebar-link">目录结构</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#流、元素和基本概念" class="sidebar-link">流、元素和基本概念</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#盒尺寸四大家族" class="sidebar-link">盒尺寸四大家族</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#内联元素与流" class="sidebar-link">内联元素与流</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#流的破坏与保护" class="sidebar-link">流的破坏与保护</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#层叠规则" class="sidebar-link">层叠规则</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#文本处理能力" class="sidebar-link">文本处理能力</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#元素的修饰与美化" class="sidebar-link">元素的修饰与美化</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#元素的显示与隐藏" class="sidebar-link">元素的显示与隐藏</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#用户界面样式" class="sidebar-link">用户界面样式</a></li><li class="sidebar-sub-header"><a href="/sugarBlog/Product/product-2/p2.html#流向的改变" class="sidebar-link">流向的改变</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="目录结构"><a href="#目录结构" aria-hidden="true" class="header-anchor">#</a> 目录结构</h2> <blockquote><p>实例代码：<a href="http://demo.cssworld.cn/" target="_blank" rel="noopener noreferrer">《CSS 世界》demo 原型页面索引<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h3 id="第-1-章-概"><a href="#第-1-章-概" aria-hidden="true" class="header-anchor">#</a> 第 1 章 概</h3> <ol><li>流体布局</li> <li><code>table</code></li> <li>CSS3</li></ol> <h3 id="第-2-章-术语和概念"><a href="#第-2-章-术语和概念" aria-hidden="true" class="header-anchor">#</a> 第 2 章 术语和概念</h3> <ol><li>未定义行为</li></ol> <h3 id="第-3-章-流、元素和基本概念"><a href="#第-3-章-流、元素和基本概念" aria-hidden="true" class="header-anchor">#</a> 第 3 章 流、元素和基本概念</h3> <ol><li><p>块级元素</p> <ul><li>为什么<code>list-item</code>元素会出现项目符号</li> <li><code>display: inline-table;</code>的盒子是怎样组成的</li> <li><code>width/height</code>作用在哪个盒子上</li></ul></li> <li><p><code>width/height</code>作用的具体细节</p> <ul><li>深藏不漏的<code>width:auto</code></li> <li><code>width</code>值作用的细节</li> <li>CSS 流体布局下的宽度分离原则</li> <li>改变<code>width/height</code>作用细节的<code>box-sizing</code></li> <li>相对简单的<code>height:auto</code></li> <li>关于<code>height:100%</code></li></ul></li> <li><p><code>min-width/max-width</code>和<code>min-height/max-height</code></p> <ul><li>为流体而生的<code>min-width/max-width</code></li> <li>与众不同的初始值</li> <li>超越<code>!important</code>，超越最大</li> <li>任意高度元素的展开收起动画技术</li></ul></li> <li><p>内联元素</p> <ul><li>哪些元素是内联元素</li> <li>内联盒模型</li> <li>幽灵空白节点</li></ul></li></ol> <h3 id="第-4-章-盒尺寸四大家族"><a href="#第-4-章-盒尺寸四大家族" aria-hidden="true" class="header-anchor">#</a> 第 4 章 盒尺寸四大家族</h3> <ol><li><p>深入理解<code>content</code></p> <ul><li><code>content</code>与替换元素</li> <li><code>content</code>内容生成技术</li></ul></li> <li><p>温和的<code>padding</code>属性</p> <ul><li><code>padding</code>与元素的尺寸</li> <li><code>padding</code>的百分比值</li> <li>标签元素内置的<code>padding</code></li> <li><code>padding</code>与图形绘制</li></ul></li> <li><p>激进的<code>margin</code>属性</p> <ul><li><code>margin</code>与元素尺寸以及相关布局</li> <li><code>margin</code>的百分比值</li> <li><code>margin</code>合并</li> <li><code>margin:auto</code></li> <li><code>margin</code>无效情形解析</li></ul></li> <li><p>功勋卓著的<code>border</code>属性</p> <ul><li>为什么<code>border-width</code>不支持百分比值</li> <li>了解各种<code>border-style</code>类型</li> <li><code>border-color</code>和<code>color</code></li> <li><code>border</code>与透明边框技巧</li> <li><code>border</code>与图形构建</li> <li><code>border</code>等高布局技术</li></ul></li></ol> <h3 id="第-5-章-内联元素与流"><a href="#第-5-章-内联元素与流" aria-hidden="true" class="header-anchor">#</a> 第 5 章 内联元素与流</h3> <ol><li><p>字母<code>x</code></p> <ul><li>字母<code>x</code>与 CSS 世界的基线</li> <li>字母<code>x</code>与 CSS 中的<code>x-height</code></li> <li>字母<code>x</code>与 CSS 中的<code>ex</code></li></ul></li> <li><p>内联元素的基石<code>line-height</code></p> <ul><li>内联元素的高度之本——<code>line-height</code></li> <li>为什么<code>line-height</code>可以让内联元素“垂直居中”</li> <li>深入<code>line-height</code>的各类属性值</li> <li>内联元素<code>line-height</code>的“大值特性”</li></ul></li> <li><p><code>line-height</code>的好朋友<code>vertical-align</code></p> <ul><li><code>vertical-align</code>家族基本认识</li> <li><code>vertical-align</code>作用前提</li> <li><code>vertical-align</code>和<code>line-height</code>之间的关系</li> <li>深入理解<code>vertical-align</code>线性类属性值</li> <li>深入理解<code>vertical-align</code>文本类属性值</li> <li>简单了解深入理解<code>vertical-align</code>线性类属性值上标下标类属性值</li> <li>无处不在的<code>vertical-align</code></li> <li>基于<code>vertical-align</code>属性的水平垂直居中弹框</li></ul></li></ol> <h3 id="第-6-章-流的破坏与保护"><a href="#第-6-章-流的破坏与保护" aria-hidden="true" class="header-anchor">#</a> 第 6 章 流的破坏与保护</h3> <ol><li><p>魔鬼属性<code>float</code></p> <ul><li><code>float</code>的本质与特性</li> <li><code>float</code>的作用机制</li> <li><code>float</code>更深入的作用机制</li> <li><code>float</code>与流体布局</li></ul></li> <li><p><code>float</code>的天然克星<code>clear</code></p> <ul><li>什么是<code>clear</code>属性</li> <li>成事不足败事有余的<code>clear</code></li></ul></li> <li><p>CSS 世界的结界——<code>BFC</code></p> <ul><li><strong>BFC</strong>的定义</li> <li><strong>BFC</strong>与流体布局</li></ul></li> <li><p>最佳结界<code>overflow</code></p> <ul><li><code>overflow</code>裁剪界线<code>border box</code></li> <li>了解<code>overflow-x</code>和<code>overflow-y</code></li> <li><code>overflow</code>与滚动条</li> <li>依赖<code>overflow</code>的样式表现</li> <li><code>overflow</code>与锚点定位</li></ul></li> <li><p><code>float</code>的兄弟<code>position:absolute</code></p> <ul><li><code>absolute</code>的包含块</li> <li>具有相对特性的无依赖<code>absolute</code>绝对定位</li> <li><code>absolute</code>与<code>text-align</code></li></ul></li> <li><p><code>absolute</code>与<code>overflow</code></p></li> <li><p><code>absolute</code>与<code>clip</code></p> <ul><li>重新认识的<code>clip</code>属性</li> <li>深入了解<code>clip</code>的渲染</li></ul></li> <li><p><code>absolute</code>的流体特性</p> <ul><li>当<code>absolute</code>遇到<code>left/top/right/bottom</code>属性</li> <li><code>absolute</code>的流体特性</li> <li><code>absolute</code>的<code>margin:auto</code>居中</li></ul></li> <li><p><code>position:relative</code>才是大哥</p> <ul><li><code>relative</code>对<code>absolute</code>的限制</li> <li><code>relative</code>与定位</li> <li><code>relative</code>的最小化影响原则</li></ul></li> <li><p>强悍的<code>position:fixed</code>固定定位</p></li></ol> <ul><li><code>position:fixed</code>不一样的“包含块”</li> <li><code>position:fixed</code>的<code>absolute</code>模拟</li> <li><code>position:fixed</code>与背景锁定</li></ul> <h3 id="第-7-章-层叠规则"><a href="#第-7-章-层叠规则" aria-hidden="true" class="header-anchor">#</a> 第 7 章 层叠规则</h3> <ol><li><code>z-index</code></li> <li>层叠上下文和层叠水平</li> <li>理解元素的层叠顺序</li> <li>牢记层叠准则</li> <li>深入了解层叠上下文
<ul><li>特性</li> <li>创建</li> <li>层叠上下文与层叠顺序</li></ul></li> <li><code>z-index</code>负值深入理解</li> <li><code>z-index</code>准则</li></ol> <h3 id="第-8-章-文本处理能力"><a href="#第-8-章-文本处理能力" aria-hidden="true" class="header-anchor">#</a> 第 8 章 文本处理能力</h3> <ol><li><p>line-height的另一个朋友font-size</p> <ul><li><code>font-size</code>和<code>vertical-align</code>的隐秘故事</li> <li>理解<code>font-size</code>与<code>ex</code>、<code>em</code>和<code>rem</code>的关系</li> <li>理解<code>font-size</code>的关键字属性值</li> <li><code>font-size:0</code>与文本的隐藏</li></ul></li> <li><p>字体属性家族font-family</p> <ul><li>了解衬线字体和无衬线字体</li> <li>等宽字体的实践价值</li> <li>中文字体和英文名称</li> <li>一些补充说明</li></ul></li> <li><p>字体家族其他成员</p> <ul><li><code>font-weight</code></li> <li><code>font-style</code></li> <li><code>font-variant</code></li></ul></li> <li><p>font属性</p> <ul><li>缩写的<code>font</code>属性</li> <li>使用关键字值得<code>font</code>属性</li> <li><code>font</code>关键字属性值的应用价值</li></ul></li> <li><p>@font face规则</p> <ul><li><code>@font face</code>的本质是变量</li> <li><code>@font face</code>与字体图标技术</li></ul></li> <li><p>文本的控制</p> <ul><li><code>text-indent</code>与内联元素缩进</li> <li><code>letter-spacing</code>与字符间距</li> <li><code>word-spacing</code>与单词间距</li> <li>了解<code>word-break</code>和<code>word-wrap</code>的区别</li> <li><code>white-space</code>与换行和空格的控制</li> <li><code>text-align</code>与元素对齐</li> <li>如何解决<code>text-decoration</code>下划线和文本重叠的问题</li> <li><code>text-transform</code>字符大小写</li></ul></li> <li><p>了解:first-letter/:first-line伪元素</p> <ul><li>深入<code>:first-letter</code>伪元素及其实例</li> <li><code>:first-line</code>伪元素</li></ul></li></ol> <h3 id="第-9-章-元素的修饰与美化"><a href="#第-9-章-元素的修饰与美化" aria-hidden="true" class="header-anchor">#</a> 第 9 章 元素的修饰与美化</h3> <ol><li><p>color</p> <ul><li>颜色关键字</li> <li>不支持的<code>transparent</code>关键字</li> <li>不支持的<code>currentColor</code>变量</li> <li>不支持的<code>rgba</code>颜色和<code>hsla</code>颜色</li> <li>支持却鸡肋的系统颜色</li></ul></li> <li><p>background</p> <ul><li>隐藏元素的<code>background-image</code>到底加不加载</li> <li>与众不同的<code>background-position</code>百分比计算方式</li> <li><code>background-repeat</code>与渲染性能</li> <li>外强中干的<code>background-attachment:fixed</code></li> <li><code>background-color</code>背景色永远是最低的</li> <li>利用多背景的属性<strong>hack</strong>小技巧</li> <li>渐变背景和<code>rgba</code>背景色的兼容处理</li></ul></li></ol> <h3 id="第-10-章-元素的显示与隐藏"><a href="#第-10-章-元素的显示与隐藏" aria-hidden="true" class="header-anchor">#</a> 第 10 章 元素的显示与隐藏</h3> <ol><li><p><code>display</code>与元素的显示/隐藏</p></li> <li><p>visibility与元素的显示/隐藏</p> <ul><li>不仅仅是保留空间</li> <li>了解<code>visibility:collapse</code></li></ul></li></ol> <h3 id="第-11-章-用户界面样式"><a href="#第-11-章-用户界面样式" aria-hidden="true" class="header-anchor">#</a> 第 11 章 用户界面样式</h3> <ol><li><p>和border形似的outline属性</p> <ul><li>绝不可以在全局设置<code>outline:0 none</code></li> <li>真正不占据空间的<code>outline</code>及其应用</li></ul></li> <li><p>光标属性cursor</p> <ul><li>琳琅满目的<code>cursor</code>属性值</li> <li>自定义光标</li></ul></li></ol> <h3 id="第-12-章-流向的改变"><a href="#第-12-章-流向的改变" aria-hidden="true" class="header-anchor">#</a> 第 12 章 流向的改变</h3> <ol><li><p>改变水平流向的direction</p> <ul><li><code>direction</code>简介</li> <li><code>direction</code>的黄金搭档<code>unicode-bidi</code></li></ul></li> <li><p>writing-mode</p> <ul><li><code>writing-mode</code>原来的作用</li> <li><code>writing-mode</code>改变了哪些规则</li> <li><code>writing-mode</code>和<code>direction</code>的关系</li></ul></li></ol> <h2 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h2> <h3 id="css3"><a href="#css3" aria-hidden="true" class="header-anchor">#</a> CSS3</h3> <ol><li>布局更丰富
<ul><li>移动端媒体查询以及响应式布局，如图片元素的<code>srcset</code>属性、<code>object-fit</code>属性</li> <li>弹性盒子布局<code>flex</code></li> <li>栅格布局<code>grid</code></li></ul></li> <li>视觉表现
<ul><li>圆角、阴影和渐变让元素更有质感</li> <li><code>transform</code>变换</li> <li><code>filter</code>滤镜和混合模式</li> <li><code>animation</code>动画</li></ul></li></ol> <h3 id="术语和概念"><a href="#术语和概念" aria-hidden="true" class="header-anchor">#</a> 术语和概念</h3> <ol><li>属性</li> <li>值
<ul><li>整数值</li> <li>数值</li> <li>百分比</li> <li>长度值</li> <li>颜色值</li></ul></li> <li>关键字</li> <li>变量</li> <li>长度单位
<ol><li>相对长度单位
<ul><li>相对字体长度单位，如<code>em</code>、<code>ex</code></li> <li>相对视区长度单位，如<code>vw</code>、<code>vh</code>、<code>vmin</code>、<code>vmax</code></li></ul></li> <li>绝对长度单位，如<code>px</code></li></ol></li> <li>功能符，值以函数的形式指定，主要用来表示颜色<code>rgba</code>、背景图片地址<code>url</code>、元素属性值、计算<code>calc</code>和过渡效果</li> <li>属性值，属性冒号<code>:</code>后面的所有内容统称为属性值</li> <li>声明</li> <li>生命块</li> <li>规则和规则集</li> <li>选择器
<ul><li>类选择器<code>.</code></li> <li>ID选择器<code>#</code></li> <li>属性选择器<code>[title]{}</code>、<code>[title=&quot;css&quot;]{}</code></li> <li>伪类选择器<code>:</code></li> <li>伪元素选择器<code>::</code></li></ul></li> <li>关系选择器
<ul><li>后代选择器，<strong>空格</strong></li> <li>相邻后代选择器，<code>&gt;</code></li> <li>兄弟选择器，<code>~</code></li> <li>相邻兄弟选择器，<code>+</code></li></ul></li> <li>@规则，<code>@media</code>、<code>@font-face</code>、<code>@page</code>、<code>@support</code></li></ol> <h3 id="未定义行为"><a href="#未定义行为" aria-hidden="true" class="header-anchor">#</a> 未定义行为</h3> <p>未定义行为就是不同浏览器对样式的支持度不一样，得到的效果也不一致。</p> <h2 id="流、元素和基本概念"><a href="#流、元素和基本概念" aria-hidden="true" class="header-anchor">#</a> 流、元素和基本概念</h2> <h3 id="块级元素"><a href="#块级元素" aria-hidden="true" class="header-anchor">#</a> 块级元素</h3> <p><code>li</code>元素默认的<code>display</code>值是<code>list-item</code>，和<code>table</code>都是块级元素，在一个水平流上只能单独显示一个元素，多个则换行显示。可以配合<code>clear</code>属性来清除浮动带来的影响。</p> <div class="language- extra-class"><pre class="language-text"><code>.clear:after {
    content: '';
    display: table; /*也可以是block，或是list-item*/
    clear: both;
}
</code></pre></div><p>实际开发中，不推荐使用<code>list-item</code>，一是会出现项目符号，而是IE不支持伪元素<code>:after</code>。</p> <h4 id="为什么list-item元素会出现项目符号"><a href="#为什么list-item元素会出现项目符号" aria-hidden="true" class="header-anchor">#</a> 为什么<code>list-item</code>元素会出现项目符号</h4> <p>list-item元素出现项目符号是因为生成了一个附加盒子（<strong>标记盒子</strong>），专门用来放圆点、数字这些项目符号。IE下伪元素不支持<code>list-item</code>或许就是无法创建<strong>标记盒子</strong>导致的。</p> <h4 id="display-inline-table-的盒子是怎样组成的"><a href="#display-inline-table-的盒子是怎样组成的" aria-hidden="true" class="header-anchor">#</a> <code>display: inline-table;</code>的盒子是怎样组成的</h4> <p>外面内联，里面<code>table</code>，元素和文字在一行显示。</p> <h4 id="width-height作用在哪个盒子上"><a href="#width-height作用在哪个盒子上" aria-hidden="true" class="header-anchor">#</a> <code>width/height</code>作用在哪个盒子上</h4> <p><code>width/height</code>作用在<strong>里面的盒子</strong>，也就是<strong>容器盒子</strong>。</p> <h4 id="width-height作用的具体细节"><a href="#width-height作用的具体细节" aria-hidden="true" class="header-anchor">#</a> <code>width/height</code>作用的具体细节</h4> <p>块级元素的流体特性主要体现在水平方向上。</p> <h4 id="深藏不漏的width-auto"><a href="#深藏不漏的width-auto" aria-hidden="true" class="header-anchor">#</a> 深藏不漏的<code>width:auto</code></h4> <p><code>width</code>的默认值是<code>auto</code>，它至少包含4中不同的宽度表现：</p> <ol><li><strong>充分利用可用空间</strong>。元素默认宽度是100%父级容器。</li> <li><strong>收缩与包裹</strong>。典型代表是浮动、绝对定位和<code>inline-block</code>元素或<code>table</code>元素。</li> <li><strong>收缩到最小</strong>。这个最容易出现在<code>table-layout</code>为<code>auto</code>表格中。</li> <li><strong>超出容器限制</strong>。除非有明确的<code>width</code>设置，否则表格<code>min-content</code>的尺寸都不会主动超出父容器的宽度。特殊情况：内容很长的英文和数字，或者内联元素设置为<code>white-space:nowrap;</code>。这种情况称为<code>max-content</code>。</li></ol> <p><strong>1. 外部尺寸与流体特性</strong></p> <ol><li>正常流宽度。**无宽度，无图片，无浮动。**充分利用浏览器自身的行为特性来完成页面布局。表现为“外部尺寸”的块级元素一旦设置了宽度就会丢失流动性。</li> <li>格式化宽度。仅出现在“绝对定位模型”中，在默认情况下，绝对定位元素的宽度表现为“包裹性”，宽度由内部尺寸决定。对于<strong>非替代元素</strong>，当<code>left/top</code>或<code>top/bottom</code>对立方位的属性值同时存在的时候，元素的宽度表现为<strong>格式化宽度</strong>，其宽度大小相对于最近的具有定位特性的祖先元素计算。格式化宽度具有完全的流体性，也就是<code>margin/padding/border/content</code>区域会自动分配水平（垂直）空间。</li></ol> <p><strong>2. 内部尺寸与流体特性</strong></p> <p>内部尺寸有3种表现特性：</p> <ol><li><p>包裹性。对于一个元素，如果其</p> <div class="language- extra-class"><pre class="language-text"><code>display:inline-block;
</code></pre></div><p>，那么里面的内容宽度不会超过容器。</p> <ul><li>按钮是CSS中最具有代表性的<code>inline-block</code>元素，也是包裹性最好的实例。具体表现为：<strong>按钮文字越多则宽度越宽（内部尺寸特性），如果文字太多则会在容器的宽度处自动换行（自适应特性）。</strong></li> <li><code>input</code>标签按钮，默认<code>white-space:pre;</code>不会换行；需要将<code>pre</code>值重置为默认的<code>normal</code>。</li></ul></li></ol> <p><strong>包裹性在实际开发中的作用</strong></p> <blockquote><p>需求：页面某个模块的文字内容是动态的，可长可短。文字少的时候居中显示，文字超过一行的时候居左显示。该如何实现？</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>.box {
    text-align: center;
}

.content {
    display: inline-block;
    text-align: left;
}
</code></pre></div><p>除了<code>inline-block</code>元素，绝对定位和浮动元素都具有包裹性，均有类似的智能宽度行为。</p> <ol><li>首选最小宽度。元素最适合的最小宽度。具体表现规则：
<ul><li>东亚文字最小宽度为每个汉字的宽度。</li> <li>西方文字最小宽度由特定的连续的英文字符单元决定。英文字符一般会终止于空格、短横线、问好以及其他非英文字符。</li> <li>要让英文字符的每个字符都用最小宽度单元，可以使用<code>word-break:break-all;</code></li> <li>图片的替代元素的最小宽度是该元素内容本身的宽度。</li></ul></li> <li>最大宽度。最大连续内联盒子的宽度。</li></ol> <h4 id="width值作用的细节"><a href="#width值作用的细节" aria-hidden="true" class="header-anchor">#</a> <code>width</code>值作用的细节</h4> <ol><li>流动性丢失
<ul><li>块级元素设定<code>width</code>具体数值，则元素的流动性就会被阻断。</li></ul></li> <li>与实际表现不一致
<ul><li><code>padding</code>、<code>border</code>属性发生改变会影响<code>content</code>内容的尺寸，出现页面布局错位。</li></ul></li></ol> <h3 id="css流体布局下的宽度分离原则"><a href="#css流体布局下的宽度分离原则" aria-hidden="true" class="header-anchor">#</a> CSS流体布局下的宽度分离原则</h3> <p><strong>宽度分离原则</strong>，就是CSS中的<code>width</code>属性不与影响宽度的<code>padding/border</code>属性共存。</p> <div class="language- extra-class"><pre class="language-text"><code>.box {
    width: 100px;
    border: 1px solid #ccc;
}
</code></pre></div><p><code>width</code>独占一层标签，而<code>padding/border/margin</code>利用流动性在内部自适应呈现。</p> <div class="language- extra-class"><pre class="language-text"><code>.father {
    width: 100px;
}

.son {
    margin: 0 20px;
    border: 1px solid #ccc;
}
</code></pre></div><h3 id="改变width-height作用细节的box-sizing"><a href="#改变width-height作用细节的box-sizing" aria-hidden="true" class="header-anchor">#</a> 改变<code>width/height</code>作用细节的<code>box-sizing</code></h3> <p><strong>box-sizing的作用</strong></p> <p>默认情况下，<code>width</code>是作用在<code>content box</code>上，<code>box-sizing</code>的作用就是可以把<code>width</code>作用的盒子变成其他几个。</p> <p><code>box-sizing: border-box;</code>就是让100像素的宽度直接作用在<code>border box</code>上，从默认的<code>content box</code>变成<code>border box</code>。此时，<code>content box</code>从宽度值中释放，形成了局部的流动性，和<code>padding</code>一起自动分配<code>width</code>值。</p> <p>box-sizing不支持<code>margin-box</code>，只有当元素没有水平<code>margin</code>时，<code>box-sizing</code>才能真正计算，<strong>宽度分离</strong>等策略可以彻底解决所有的宽度计算问题。</p> <blockquote><p>在CSS世界中，唯一离不开<code>box-sizing:border-box;</code>的就是原生普通文本框<code>input</code>和<code>textarea</code>的100%自适应父容器宽度。 替换元素的特性之一是尺寸由内部元素决定，且无论其<code>display</code>属性值是<code>inline</code>还是<code>block</code>。对于非替换元素，如果<code>display</code>值是<code>block</code>，就会具有流动性，宽度由外部尺寸决定，但是替换元素的宽度不受<code>display</code>水平影响，因此，通过修改<code>textarea</code>的<code>display</code>水平是无法让尺寸100%自适应父容器。</p></blockquote> <h3 id="相对简单的height-auto"><a href="#相对简单的height-auto" aria-hidden="true" class="header-anchor">#</a> 相对简单的<code>height:auto</code></h3> <h3 id="关于height-100"><a href="#关于height-100" aria-hidden="true" class="header-anchor">#</a> 关于<code>height:100%</code></h3> <p>对于<code>width</code>属性，父元素<code>width</code>设为<code>auto</code>，其百分比也支持；但是对于<code>height</code>属性，如果父元素<code>height</code>设为<code>auto</code>，只要子元素在文档流中，其百分比完全被忽略。</p> <blockquote><p>对于普通文档流中的元素，百分比高度值要想起作用，其父级必须有一个可以生效的高度值。</p></blockquote> <p><strong>1. 父级没有具体高度值，height:100%;会无效</strong></p> <blockquote><p>浏览器渲染的基本原理：首先，先下载文档内容，加载头部的样式资源，然后按照从上而下、自外而内的顺序渲染DOM内容。</p></blockquote> <p>如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为<code>auto</code>。</p> <p><strong>2. 让元素支持height:100%效果</strong></p> <ol><li><p>设定显式的高度值。</p> <p>html, body { height: 100%; }</p></li> <li><p>使用绝对定位。</p> <p>div { height: 100%; position: absolute; }</p></li></ol> <blockquote><p>绝对定位的宽高百分比计算是相对于<code>padding box</code>，也就是会把<code>padding</code>大小值计算在内。非绝对定位元素则是相对于<code>content box</code>计算。</p></blockquote> <p><strong>图片左右半区点击分别上一张图下一张图效果</strong></p> <p>在图片外面包一层具有“包裹性”同时具有定位特性的标签。</p> <div class="language- extra-class"><pre class="language-text"><code>.box {
    display: inline-block;
    position: relative;
}
</code></pre></div><p>在图片上覆盖两个绝对定位，同时设<code>height:100%;</code>，则无论图片多高，左右半区都能自动和图片高度一模一样，无需任何使用JS的计算。</p> <h3 id="min-width-max-width和min-height-max-height"><a href="#min-width-max-width和min-height-max-height" aria-hidden="true" class="header-anchor">#</a> <code>min-width/max-width</code>和<code>min-height/max-height</code></h3> <h3 id="为流体而生的min-width-max-width"><a href="#为流体而生的min-width-max-width" aria-hidden="true" class="header-anchor">#</a> 为流体而生的<code>min-width/max-width</code></h3> <p><code>min-width/max-width</code>出现的场景一定是自适应布局或流体布局中。</p> <div class="language- extra-class"><pre class="language-text"><code>.container {
    min-width: 1200px;
    max-width: 1400px;
}
</code></pre></div><p>为了避免图片在移动端展示过大影响体验，经常会有下面的<code>max-width</code>限制：</p> <div class="language- extra-class"><pre class="language-text"><code>img {
    max-width: 100%;
    height: auto !important;
}
</code></pre></div><p><code>height:auto;</code>是必须的，否则如果原始图片有设定<code>height</code>，<code>max-width</code>生效时图片就会被水平压缩。强制<code>height</code>为<code>auto</code>可以确保宽度不超出的同时使图片保持原来的比例。</p> <h3 id="与众不同的初始值"><a href="#与众不同的初始值" aria-hidden="true" class="header-anchor">#</a> 与众不同的初始值</h3> <p><code>max-width/max-height</code>的初始值是<code>none</code>，<code>min-width/min-height</code>的初始值是<code>auto</code>。</p> <ol><li><code>min-height/width</code>的值为<code>auto</code>合法。</li> <li>数值变化无动画。<code>min-height</code>的初始值是<code>auto</code>。</li></ol> <h3 id="超越-important，超越最大"><a href="#超越-important，超越最大" aria-hidden="true" class="header-anchor">#</a> 超越<code>!important</code>，超越最大</h3> <p><strong>1. 超越!important</strong></p> <p>超越<code>!important</code>指的是<code>max-width</code>会覆盖<code>width</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;img src=&quot;1.jpg&quot; style=&quot;width: 480px !important;&quot; alt=&quot;&quot;&gt;
img {
    max-width: 256px;
}
</code></pre></div><p>最终图片显示宽度<code>256px</code>。</p> <p><strong>2. 超越最大</strong></p> <p><strong>超越最大</strong>指的是<code>min-width</code>覆盖<code>max-width</code>，此规则发生在<code>min-width</code>和<code>max-width</code>冲突的时候。</p> <div class="language- extra-class"><pre class="language-text"><code>.container {
    min-width: 1400px;
    max-width: 1200px;
}
</code></pre></div><p>最小宽度设置比最大宽度还大，这个时候，<code>min-width</code>显示，<code>max-width</code>被忽略。<code>.container</code>元素表现为至少<code>1400px</code>宽度。</p> <h3 id="任意高度元素的展开收起动画技术"><a href="#任意高度元素的展开收起动画技术" aria-hidden="true" class="header-anchor">#</a> 任意高度元素的展开收起动画技术</h3> <p><strong>元素展开收起时有明显的高度滑动效果</strong></p> <div class="language- extra-class"><pre class="language-text"><code>.element {
    max-height: 0;
    overflow: hidden;
    transition: max-height .25s;
}

.element.active {
    max-height: 666px;
}
</code></pre></div><p><code>max-height</code>使用足够安全的最小值，避免出现延迟。</p> <h3 id="内联元素"><a href="#内联元素" aria-hidden="true" class="header-anchor">#</a> 内联元素</h3> <p>在CSS世界中，内联元素是最为重要的。这些CSS属性往往具有继承特性。</p> <h4 id="哪些元素是内联元素"><a href="#哪些元素是内联元素" aria-hidden="true" class="header-anchor">#</a> 哪些元素是内联元素</h4> <p>**1. 从定义看 **</p> <p>内联元素特指“外在盒子”，和<code>display:inline;</code>的元素不是一个概念。</p> <p><strong>2. 从表现看</strong></p> <p>内联元素的典型特性是可以和文字在一行显示。</p> <h4 id="内联盒模型"><a href="#内联盒模型" aria-hidden="true" class="header-anchor">#</a> 内联盒模型</h4> <ol><li><p>内容区域。</p> <ul><li><strong>内容区域</strong>指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个<code>字符盒子</code>。</li> <li>但是像图片这类替换元素，内容区域可以看成元素本身。可以把文本选中的背景色区域作为内容区域。</li> <li></li></ul></li> <li><p>内联盒子。</p> <ul><li><p><strong>内联盒子</strong>不会让内容成块显示，而是排成一行，<strong>内联盒子</strong>指的就是“外在盒子”，用来决定元素是内联还是块级。</p></li> <li><p>外在盒子</p> <p>又可以划分为“内联盒子”和“匿名内联盒子”两类：</p> <ul><li>外部内联标签<code>span</code>、<code>a</code>、<code>em</code>等，则属于“内联盒子”；如果这是文字<code>&lt;p&gt;这是一行普通文字，这里有个&lt;em&gt;em&lt;/em&gt;标签。（这里是匿名内联盒子）&lt;/p&gt;</code>，则属于“匿名内联盒子”。</li> <li>并非单独文字都是“匿名内联盒子”，关键要看前后的标签是内联还是块级。</li></ul></li></ul></li> <li><p>行框盒子。</p> <ul><li>每一行就是一个“行框盒子”，每个“行框盒子”又是由一个个“内联盒子”组成。</li></ul></li> <li><p>包含盒子。</p> <ul><li><code>p</code>标签就是一个<strong>包含盒子</strong>，此盒子由一行一行的“行框盒子”组成。</li></ul></li></ol> <h3 id="幽灵空白节点"><a href="#幽灵空白节点" aria-hidden="true" class="header-anchor">#</a> 幽灵空白节点</h3> <p><strong>幽灵空白节点</strong>具体指的是：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，但又确实存在，表现如同文本节点一样。</p> <p><strong>幽灵空白节点</strong>是一个存在于每个“行框盒子”前面，同时具有该元素的字体和行高属性的<code>0</code>宽度的内联盒。</p> <h2 id="盒尺寸四大家族"><a href="#盒尺寸四大家族" aria-hidden="true" class="header-anchor">#</a> 盒尺寸四大家族</h2> <h3 id="深入理解content"><a href="#深入理解content" aria-hidden="true" class="header-anchor">#</a> 深入理解<code>content</code></h3> <h4 id="content与替换元素"><a href="#content与替换元素" aria-hidden="true" class="header-anchor">#</a> <code>content</code>与替换元素</h4> <h5 id="_1-什么是替换元素"><a href="#_1-什么是替换元素" aria-hidden="true" class="header-anchor">#</a> 1. 什么是替换元素</h5> <p>通过修改某个属性值呈现的内容就可以被替换的元素称为<strong>替换元素</strong>。因此，<code>img</code>、<code>object</code>、<code>video</code>、<code>iframe</code>或者表单元素<code>textarea</code>和<code>input</code>都是典型的替换元素。</p> <p>替换元素除了内容可替换这一特性外，还有一些特性：</p> <ol><li><strong>内容的外观不受页面上的CSS的影响</strong>。样式表现在CSS作用域之外。更改替换元素自身的外观需要浏览器自身暴露的一些样式接口。</li> <li><strong>有自己的尺寸</strong>。替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是<code>300px*150px</code>。</li> <li>**在很多CSS属性上有自己的一套表现规则。**比较具有代表性的就是<code>vertical-align</code>属性。对于非替换元素，<code>vertical-align</code>的默认值是<code>baseline</code>，被定义为字符<code>x</code>的下边缘；对于替换元素的内容没有字符<code>x</code>，替换元素的基线就被定义为元素的下边缘。</li></ol> <h5 id="_2-替换元素的默认display值"><a href="#_2-替换元素的默认display值" aria-hidden="true" class="header-anchor">#</a> 2. 替换元素的默认<code>display</code>值</h5> <p>所有的替换元素都是内联元素，也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。</p> <blockquote><p>各个替换元素的默认<code>display</code>属性值（P46）</p></blockquote> <p>**<code>input</code>和<code>button</code>按钮的区别在什么地方？**区别在于两种按钮默认的<code>white-space</code>值不一样，前者是<code>pre</code>，后者是<code>normal</code>，所表现出来的差异是：<strong>当按钮文字足够多时，input按钮不会自动换行，button按钮则会。</strong></p> <blockquote><p>替换元素的<code>display</code>是<code>inline</code>、<code>block</code>和<code>inline-block</code>中的任意一个，其尺寸计算规则都是一样的。</p></blockquote> <h5 id="_3-替换元素的尺寸计算规则"><a href="#_3-替换元素的尺寸计算规则" aria-hidden="true" class="header-anchor">#</a> 3. 替换元素的尺寸计算规则</h5> <p>替换元素的尺寸从内到外分为3类：固有尺寸、HTML尺寸和CSS尺寸。</p> <ol><li>固有尺寸指的是替换内容原本的尺寸。</li> <li>HTML尺寸<code>img</code>、<code>input</code>只能通过HTML原生属性改变。</li> <li>CSS尺寸指的是可以通过CSS的<code>width</code>和<code>height</code>或者<code>max-width/min-width</code>和<code>max-height/min-width</code>设置的尺寸，对应盒尺寸的<code>content box</code>。</li></ol> <blockquote><p>可以影响替换元素的3层结构（由里到外）：固有尺寸-&gt;HTML尺寸-&gt;CSS尺寸</p></blockquote> <p>这3层结构的计算规则：</p> <ul><li>如果没有CSS尺寸和HTML尺寸，使用固有尺寸作为最终的宽高。</li></ul> <p>页面显示宽高就是图片自身的尺寸<code>256px*192px</code>。</p> <ul><li>如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</li></ul> <p>通过HTML属性<code>width</code>和<code>height</code>限定了图片的HTML尺寸，因此最终图片所呈现的宽高就是<code>128px*128px</code>。</p> <ul><li>如果有CSS尺寸，则最终尺寸由CSS属性决定。</li></ul> <p>此时，固有尺寸、CSS尺寸和HTML尺寸同时存在，起作用的是CSS属性限定的尺寸，因此，最终图片所呈现的宽高就是<code>200px*150px</code>。</p> <ul><li>如果固有尺寸含有固有的宽高比例，同时仅设置了宽度或高度，则元素依然按照固有的宽高比例显示。</li></ul> <p>设置的宽度，因为图片自身有着固定的宽高比例，所以最终图片呈现的宽高就是<code>200px*150px</code>（<code>150=200+192/256</code>）</p> <ul><li>如果条件不符合，在所有现代浏览器下的尺寸表现都是<code>300px*150px</code>。</li> <li>内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</li></ul> <blockquote><p>实际开发中，为了提高加载性能和节约带宽费用，首屏图片采用滚屏的方式异步加载，并且使用一张透明的图片占位。一般直接使用<code>&lt;img&gt;</code>。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>img {
    visibility: hidden;
}

img[src] {
    visibility: visible;
}
</code></pre></div><p>当<code>img</code>标签中有<code>src</code>属性时，即使为空，浏览器依然会发起请求，而且请求的是当前页面数据。当图片的<code>src</code>缺省时，图片不会有任何请求，是最高效的实现方式。</p> <p>Firefox下<code>img</code>的表现是一个内联元素，而非替换元素，因此很多设置都它下面无效。要修复这个问题非常简单，就是直接设置<code>img {display:inline-block;}</code></p> <blockquote><p>在CSS中，图片的固有尺寸是无法改变的，显示的仅仅是设定的<code>content box</code>尺寸，图片中的<code>content</code>替换内容默认的适配方式是填充<code>fill</code>。 尺寸变化的本质并不是改变固有尺寸，而是采用了填充作为适配HTML尺寸和CSS尺寸的方式。 在CSS3中，<code>img</code>以及其它替换元素的适配方式可以通过<code>object-fit</code>属性进行修改。</p></blockquote> <h5 id="_4-替换元素和非替换元素的距离"><a href="#_4-替换元素和非替换元素的距离" aria-hidden="true" class="header-anchor">#</a> 4. 替换元素和非替换元素的距离</h5> <h6 id="观点1：替换元素和非替换元素之间只隔了一个src属性"><a href="#观点1：替换元素和非替换元素之间只隔了一个src属性" aria-hidden="true" class="header-anchor">#</a> <strong>观点1：替换元素和非替换元素之间只隔了一个src属性</strong></h6> <p>如果把<code>img</code>的<code>src</code>属性去掉，<code>img</code>就是一个和<code>span</code>类似的普通的内联标签，也就变成了一个非替换元素。</p> <div class="language- extra-class"><pre class="language-text"><code>img {
    display: block;
    outline: 1px solid;
}
&lt;img&gt;
</code></pre></div><p>在Firefox下，最终的宽度是100%自适应父容器的可用宽度。<strong>span标签设置width和height是无效的。如果设置<img alt="图片">不为空的alt值，Chrome下也会有同样的表现。</strong></p> <blockquote><p>在IE中有个默认的占位替换内容，当<code>src</code>属性缺失时，会使用这个默认的占位内容，这也是IE浏览器下默认<code>img</code>尺寸是<code>28*30</code>，而不是Chrome下的<code>0*0</code>的原因。</p></blockquote> <p>另一个证明<strong>替换元素和非替换元素的区别在于src属性</strong>的实例就是<strong>基于伪元素的图片内容生成技术。</strong></p> <p>可以对<code>img</code>元素使用<code>::before</code>和<code>::after</code>伪元素进行内容生成以及样式构建，为了解决兼容性问题，需要注意一些技术点：</p> <ol><li>不能有<code>src</code>属性（关键所在）</li> <li>不能使用<code>content</code>属性生成图片（针对Chrome）</li> <li>需要有<code>alt</code>属性并且有值（针对Chrome）</li> <li>Firefox下<code>::before</code>伪元素的<code>content</code>值会被无视，<code>::after</code>无此问题，应该与Firefox自己占用了<code>::before</code>伪元素的<code>content</code>有关。</li></ol> <blockquote><p><strong>基于伪元素的图片内容生成技术</strong>，在图片还没有加载时把<code>alt</code>信息呈现出来。</p></blockquote> <blockquote><p>实例Demo：<a href="http://demo.cssworld.cn/4/1-2.php" target="_blank" rel="noopener noreferrer">src缺省时img元素的alt信息展示<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h6 id="观点2：替换元素和非替换元素之间只隔了一个csscontent属性"><a href="#观点2：替换元素和非替换元素之间只隔了一个csscontent属性" aria-hidden="true" class="header-anchor">#</a> <strong>观点2：替换元素和非替换元素之间只隔了一个CSScontent属性</strong></h6> <p><code>content</code>属性决定了是替换元素还是非替换元素。</p> <p>以下两个实例是等效的：</p> <div class="language- extra-class"><pre class="language-text"><code>//组一
img {
    content: url(&quot;https://www.baidu.com/img/bd_logo1.png&quot;);
}
&lt;img&gt;

&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot;&gt;

//组二
&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot;&gt;

img:hover {
    content: url(&quot;logo.jpg&quot;);
}   
</code></pre></div><p>使用<code>content</code>属性，可以让普通标签元素变成替换元素。</p> <h5 id="_5-content与替换元素关系"><a href="#_5-content与替换元素关系" aria-hidden="true" class="header-anchor">#</a> 5. <code>content</code>与替换元素关系</h5> <p><code>content</code>生成的内容和普通内容有很多不同的特性表现：</p> <ol><li>使用<code>content</code>生成的文本无法选中、无法复制，无法被屏幕阅读设备读取，也无法被搜索引擎抓取。</li> <li>不能左右<code>:empty</code>伪类。<code>:empty</code>是一个CSS选择器，当元素里面无内容时进行匹配。</li> <li><code>content</code>动态生成值无法获取。<code>content</code>可以实现计算器效果，可以自动累加数值。</li></ol> <h3 id="content内容生成技术"><a href="#content内容生成技术" aria-hidden="true" class="header-anchor">#</a> <code>content</code>内容生成技术</h3> <h4 id="_1-content辅助元素生成"><a href="#_1-content辅助元素生成" aria-hidden="true" class="header-anchor">#</a> 1. <code>content</code>辅助元素生成</h4> <div class="language- extra-class"><pre class="language-text"><code>.element:before {
    content: '';
}
</code></pre></div><p>辅助元素最常见的应用就是<strong>清除浮动</strong>带来的影响：</p> <div class="language- extra-class"><pre class="language-text"><code>.clear:after {
    content: '';
    display: table; /*也可以是block*/
    clear: both;
}
</code></pre></div><p>另一个很具有代表性的应用就是<strong>辅助实现“两端对齐”以及“垂直居中/上边缘/下边缘对齐”效果</strong></p> <p><code>:before</code>伪元素用于辅助实现底对齐，<code>:after</code>伪元素用于辅助实现两端对齐。</p> <h4 id="_2-content字符内容生成"><a href="#_2-content字符内容生成" aria-hidden="true" class="header-anchor">#</a> 2. <code>content</code>字符内容生成</h4> <p>直接写入字符内容，常见应用是配合<code>@font-face</code>规则实现图标字体效果。</p> <p>插入Unicode字符，典型应用是插入换行符来实现某些布局或效果。</p> <div class="language- extra-class"><pre class="language-text"><code>:after {
    content: '\A';
    white-space: pre;
}
</code></pre></div><p><code>\A</code>是换行符中的LF字符，其Unicode编码是<code>000A</code>，在CSS的<code>content</code>属性中则直接写成<code>\A</code>;换行符中的CR字符，其Unicode编码是<code>000D</code>，在CSS的<code>content</code>属性中则直接写成<code>\D</code>。分别指回车<code>CR</code>和换行<code>LF</code>。</p> <h4 id="_3-content图片生成"><a href="#_3-content图片生成" aria-hidden="true" class="header-anchor">#</a> 3. <code>content</code>图片生成</h4> <p><code>base64</code>图片由于内联在CSS文件中，直接出现没有尺寸为<code>0</code>的状态，同时无须额外设置<code>display:block/inline-block;</code>，CSS代码更省。</p> <h4 id="_4-content开启闭合符号生成p63"><a href="#_4-content开启闭合符号生成p63" aria-hidden="true" class="header-anchor">#</a> 4. <code>content</code>开启闭合符号生成P63</h4> <h4 id="_5-content-attr属性值内容生成"><a href="#_5-content-attr属性值内容生成" aria-hidden="true" class="header-anchor">#</a> 5. <code>content attr</code>属性值内容生成</h4> <div class="language- extra-class"><pre class="language-text"><code>.icon:before {
    content: attr(data-title);
}
</code></pre></div><h4 id="_6-深入理解content计数器"><a href="#_6-深入理解content计数器" aria-hidden="true" class="header-anchor">#</a> 6. 深入理解<code>content</code>计数器</h4> <ol><li><p>属性<code>counter-reset</code>，计数器重置，还可以设置为<code>none</code>和<code>inherit</code>。取消重置以及继承重置。</p></li> <li><p>属性<code>counter-increment</code>，计数器递增，计数器数值变化遵循HTML渲染顺序，遇到一个<code>increment</code>计数器就变化，<code>counter</code>输出的时候就是此时的计数值。</p> <p><code>counter-increment</code>的其他特性：</p> <ul><li><code>counter-reset</code>可以一次命名两个计数器名称，<code>counter-increment</code>相对应的设定。</li> <li>变化的值可以灵活设定。</li> <li>值可以是<code>none</code>或<code>inherit</code></li></ul></li> <li><p>方法<code>counter()/counters()</code>。</p> <ul><li><code>counter(name)</code></li> <li><code>counter(name,style)</code>，<code>style</code>参数支持关键字值是<code>list-style-type</code>所支持的值。它的作用是：除了递增递减数字，还可以是英文字母或罗马字符等。</li> <li><code>counter</code>还支持级联。一个<code>counter</code>属性值可有多个<code>coutner()</code>方法。</li></ul></li></ol> <p><code>coutners()</code>方法就是<strong>嵌套计数</strong>，基本用法是<code>counters(name,string);</code>，其中，<code>string</code>参数为字符串（需要引号，是必需参数），表示子序号的连接字符串。</p> <p>实现嵌套，<strong>必须让每个列表容器拥有一个唯一的计数源</strong>，通过子辈对父辈的<code>counter-reset</code>重置、配合<code>counters()</code>方法才能实现计数嵌套效果。</p> <blockquote><p>一个容器的<code>counter-reset</code>是唯一的，一旦子元素出现<code>counter-reset</code>。就会改变整个容器的嵌套关系。</p></blockquote> <p><code>counters()</code>支持<code>style</code>自定义递增形式：</p> <div class="language- extra-class"><pre class="language-text"><code>counters(name, string, style);
</code></pre></div><h4 id="_7-content内容生成的混合特性"><a href="#_7-content内容生成的混合特性" aria-hidden="true" class="header-anchor">#</a> 7. <code>content</code>内容生成的混合特性</h4> <p><code>content</code>内容生成的混合特性指的是各种<code>content</code>内容生成语法可以混合在一起使用。</p> <h3 id="温和的padding属性"><a href="#温和的padding属性" aria-hidden="true" class="header-anchor">#</a> 温和的<code>padding</code>属性</h3> <h4 id="padding与元素的尺寸"><a href="#padding与元素的尺寸" aria-hidden="true" class="header-anchor">#</a> <code>padding</code>与元素的尺寸</h4> <p>CSS中默认的<code>box-sizing</code>是<code>content-box</code>，使用<code>padding</code>会增加元素的尺寸。</p> <p>内联元素的<code>padding</code>在垂直方向会影响布局，影响视觉表现。内联元素没有可视宽度/高度（<code>clientWidth/clientHeight</code>永远为<code>0</code>），垂直方向的行为表现完全受<code>line-height</code>和<code>vertical-align</code>的影响。</p> <p><strong>利用内联元素的padding实现高度可控的分割线。</strong></p> <p>网页通过地址栏的<code>hash</code>值和页面HTML的<code>id</code>值一样发生锚点定位。</p> <blockquote><p><strong>内联元素设置padding不会影响布局，但是块级元素就会。</strong></p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;h3&gt;&lt;span id=&quot;hash&quot;&gt;标题&lt;/span&gt;&lt;/h3&gt;
h3 {
    line-height: 30px;
    font-size: 14px;
}

h3 &gt; span {
    padding-top: 58px;
}
</code></pre></div><p><strong>对于非替换元素的内联元素，不仅padding不会加入行盒高度的计算，margin/border也都是如此，都是不计算高度，但实际上在内联盒周围发生了渲染。</strong></p> <h4 id="padding的百分比值"><a href="#padding的百分比值" aria-hidden="true" class="header-anchor">#</a> <code>padding</code>的百分比值</h4> <p><code>padding</code>属性值不支持负值，支持百分比值，<code>padding</code>百分比值无论是水平方向还是垂直方向均是相对于宽度计算。</p> <p><strong>实现一个固定比例（宽高比）的头图效果。</strong></p> <div class="language- extra-class"><pre class="language-text"><code>.box {
    padding: 10% 50%;
    position: relative;
}

.box &gt; img {
    position: absolute;
    width: 100%;
    height: 100%;
    left: 0;
    top: 0;
}
</code></pre></div><p>内联元素和块状元素应用百分比值的表现：</p> <ul><li>同样相对于宽度计算；</li> <li>默认的高度和宽度细节有差异；</li> <li><code>padding</code>会断行。</li></ul> <p><strong>内联元素的垂直padding会让“幽灵空白节点”出现。</strong></p> <p>内联元素默认的高度完全受<code>font-size</code>大小控制。通过以下方法使得“幽灵空白节点”高度变为<code>0</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>span{
    padding: 50%;
    font-size: 0;
    background-color: gray;
}
</code></pre></div><h4 id="标签元素内置的padding"><a href="#标签元素内置的padding" aria-hidden="true" class="header-anchor">#</a> 标签元素内置的<code>padding</code></h4> <ol><li><code>ol/ul</code>列表内置<code>padding-left</code>，单位是<code>px</code>，如果列表中的<code>font-size</code>值很小，则<code>li</code>元素的项目符号就会在<code>ol/ul</code>元素的左边缘距离很开。</li> <li>表单元素大都内置padding。
<ul><li>所有浏览器<code>input/textarea</code>输入框内置<code>padding</code></li> <li>所有浏览器<code>button</code>按钮内置<code>padding</code></li> <li>部分浏览器<code>select</code>下拉内置<code>padding</code></li> <li>所有浏览器<code>radio/checkbox</code>单复选框无内置<code>padding</code></li> <li><code>button</code>按钮元素的<code>padding</code>最难控制</li></ul></li></ol> <p><strong>使用label元素解决button按钮在不同浏览器下padding表现不一致的问题</strong></p> <div class="language- extra-class"><pre class="language-text"><code>button {
    position: absolute;
    clip: rect(0 0 0 0);
}

label {
    display: inline-block;
    line-height: 20px;
    padding: 10px;
}
</code></pre></div><h4 id="padding与图形绘制"><a href="#padding与图形绘制" aria-hidden="true" class="header-anchor">#</a> <code>padding</code>与图形绘制</h4> <p><strong>“三道杠”小图标</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;icon-menu&quot;&gt;&lt;/div&gt;
.icon-menu {
    display: inline-block;
    width: 100px;
    height: 8px;
    padding: 20px 0;
    border-top: 8px solid;
    border-bottom: 8px solid;
    background-color: currentColor;
    background-clip: content-box;
}
</code></pre></div><p><strong>“双层圆点”图</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;icon-dot&quot;&gt;&lt;/div&gt;
.icon-dot {
    display: inline-block;
    width: 100px;
    height: 100px;
    padding: 10px;
    border: 10px solid;
    border-radius: 50%;
    background-color: currentColor;
    background-clip: content-box;
}
</code></pre></div><h3 id="激进的margin属性"><a href="#激进的margin属性" aria-hidden="true" class="header-anchor">#</a> 激进的<code>margin</code>属性</h3> <h4 id="margin与元素尺寸以及相关布局"><a href="#margin与元素尺寸以及相关布局" aria-hidden="true" class="header-anchor">#</a> <code>margin</code>与元素尺寸以及相关布局</h4> <p><strong>1. 元素尺寸</strong></p> <ul><li><strong>元素尺寸</strong>：对应jQuery中的<code>$().width/$().height()</code>方法，包括<code>padding/border</code>，也就是元素的<code>border box</code>的尺寸。在原生的<strong>DOM API</strong>中写成<code>offsetWidth/offsetHeight</code>，也称为<strong>元素偏移尺寸</strong>。</li> <li><strong>元素内部尺寸</strong>：对应jQuery中的<code>$().innerWidth()/$().innerHeight()</code>方法，表示元素的内部尺寸，包括<code>padding</code>但不包括<code>border</code>，也就是元素的<code>padding box</code>的尺寸。在原生的<strong>DOM API</strong>中写成<code>clientWidth/clientHeight</code>，也称为<strong>元素可视尺寸</strong>。</li> <li><strong>元素外部尺寸</strong>：对应jQuery中的<code>$().outerWidth(true)/$().outerHeight(true)</code>方法，表示元素的外部尺寸，包括<code>padding/border/margin</code>，也就是元素的<code>margin box</code>的尺寸。没有对应的原生的<strong>DOM API</strong>。</li></ul> <p><strong>2. margin与元素的内部尺寸</strong></p> <blockquote><p><strong>一侧定宽的两栏自适应布局效果</strong></p></blockquote> <ol><li>如果图片左侧定位：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;box&quot;&gt;
    &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;
    &lt;p&gt;文字内容...&lt;/p&gt;
&lt;/div&gt;
.box {
    overflow: hidden;
}

.box &gt; img {
    float: left;
}

.box &gt; p {
    margin-left: 140px;
}
</code></pre></div><p>文字内容根据<code>.box</code>盒子的宽度变化而自动排列，形成自适应布局效果。</p> <ol><li>如果图片右侧定位：改变浮动和<code>margin</code>方向。借助<code>margin</code>负值定位实现。</li> <li>如果图片右侧定位，同时顺序一致：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;full&quot;&gt;
        &lt;p&gt;文字内容...&lt;/p&gt;
    &lt;/div&gt;
    &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot;&gt;
&lt;/div&gt;
.box {
    overflow: hidden;
}

.full {
    width: 100%;
    float: left;
}

.box &gt; img {
    float: left;
    margin-left: -128px;
}

.full &gt; p {
    margin-right: 140px;
}
</code></pre></div><ol><li>如果图片右侧定位，同时顺序一致。</li></ol> <blockquote><p>需求：列表块两端对齐，一行显示3个，中间有2个<code>20px</code>的间隙。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>ul {
    list-style-type: none;
    margin-right: -20px;
}

ul &gt; li {
    float: left;
    width: 100px;
    margin-right: 20px;
    background-color: #a0b3d6;
}
</code></pre></div><p><strong>3. margin与元素的外部尺寸</strong></p> <blockquote><p>借助<code>margin</code>的外部尺寸特性来实现底部留白。只能使用子元素的<code>margin-bottom</code>来实现滚动容器的底部留白。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;div style=&quot;height: 200px;&quot;&gt;
    &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot; style=&quot;margin: 50px 0;&quot;&gt;
&lt;/div&gt;
</code></pre></div><blockquote><p>利用<code>margin</code>外部尺寸实现等高布局。此布局多出现在分栏有背景色或中间有分割线的布局中。<code>height:100%</code>需要在父级设定具体高度值时才有效。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;column-box&quot;&gt;
    &lt;div class=&quot;column-left&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;column-right&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
.column-box {
    overflow: hidden;
}

.column-left, .column-right {
    margin-bottom: -9999px;
    padding-bottom: 9999px;
}
</code></pre></div><blockquote><p><strong>等高布局实现原理</strong></p></blockquote> <p>垂直方向<code>margin</code>无法改变元素的内部尺寸，但却能改变外部尺寸。默认情况下，垂直方向块级元素上下距离是<code>0</code>，一旦设置<code>margin-bottom:-9999px;</code>后面所有元素和上面元素的空间距离变成<code>-9999px</code>，就是后面元素都往上移动<code>9999px</code>。<code>padding-bottom:9999px;</code>增加元素高度，正负一抵消，对布局层并无影响，但视觉层多了<code>9999px</code>高度的可使用的背景色。配合<code>overflow:hidden;</code>把多余的色块背景隐藏，实现视觉上的等高布局效果。</p> <h3 id="margin的百分比值"><a href="#margin的百分比值" aria-hidden="true" class="header-anchor">#</a> <code>margin</code>的百分比值</h3> <p>元素设置<code>margin</code>在垂直方向上无法改变元素自身的内部尺寸，往往需要父元素作为载体，此外，由于<code>margin</code>合并的存在，垂直方向往往需要双倍尺寸才能和<code>padding</code>表现一致。</p> <h4 id="margin合并"><a href="#margin合并" aria-hidden="true" class="header-anchor">#</a> <code>margin</code>合并</h4> <p>块级元素的上边距<code>margin-top</code>与下边距<code>margin-bottom</code>有时会合并为单个外边距。</p> <ol><li><strong>块级元素</strong>，但不包括浮动和绝对定位元素。</li> <li><strong>只发生在垂直方向</strong>，默认文档流是水平的，因此发生<code>margin</code>合并就是垂直方向。</li></ol> <p><strong>margin合并的3种场景</strong></p> <ol><li>相邻兄弟元素<code>margin</code>合并。</li> <li>父级和第一个/最后一个子元素。</li></ol> <p><strong>阻止margin合并</strong></p> <p>对于<code>margin-top</code>合并，可以进行如下操作（满足一个条件即可）：</p> <ul><li>父元素设置为块状格式化上下文元素</li> <li>父元素设置<code>border-top</code>值；</li> <li>父元素设置<code>padding-top</code>值；</li> <li>父元素和第一个子元素之间添加内联元素进行分隔。</li></ul> <p>对于<code>margin-bottom</code>合并，可以进行如下操作（满足一个条件即可）：</p> <ul><li>父元素设置为块状格式化上下文元素</li> <li>父元素设置<code>border-bottom</code>值；</li> <li>父元素设置<code>padding-bottom</code>值；</li> <li>父元素和第一个子元素之间添加内联元素进行分隔。</li> <li>父元素设置<code>height</code>、<code>min-height</code>、<code>max-height</code></li></ul> <p><code>margin</code>合并导致头图掉下来可以添加<code>.container{overlfow:hidden;}</code>进行修复。</p> <p>其原理是通过设置<code>overflow</code>属性让父级元素块状格式化上下文。</p> <ol><li>空块级元素的<code>margin</code>合并。<code>border</code>阻断<code>margin</code>合并。</li></ol> <blockquote><p>不希望空<code>div</code>元素有<code>margin</code>合并，可以进行如下操作：</p></blockquote> <ul><li>设置垂直方向的<code>border</code></li> <li>设置垂直方向的<code>padding</code></li> <li>里面添加内联元素（直接Space空格键无效）</li> <li>设置<code>height</code>或<code>min-height</code></li></ul> <p><strong>3. margin合并的计算规则</strong></p> <blockquote><p><code>margin</code>合并的计算规则总结为<strong>正正取大值</strong>，<strong>正负值相加</strong>，<strong>负负最负值</strong></p></blockquote> <p><strong>4. margin合并的意义</strong></p> <p>合并机制可以保证元素上下间距一致。</p> <p>父子<code>margin</code>合并的意义在于：在页面上任何地方嵌套或直接放入任何空<code>div</code>，都不会影响原来的块布局。</p> <p>遇到列表或模块，全部保留上下<code>margin</code>设置：</p> <div class="language- extra-class"><pre class="language-text"><code>.list {
    margin-top: 15px;
    margin-bottom: 15px;
}
</code></pre></div><h4 id="margin-auto"><a href="#margin-auto" aria-hidden="true" class="header-anchor">#</a> <code>margin:auto</code></h4> <ol><li>元素没有设置<code>width/height</code>，也会自动填满容器。</li> <li>元素没有设置<code>width/height</code>，也会自动填满包含块容器。</li></ol> <p><code>margin:auto</code>的填充规则：</p> <ol><li>如果一侧定值，一侧<code>auto</code>，则<code>auto</code>为剩余空间大小。</li> <li>如果两侧均是<code>auto</code>，则平分剩余空间。</li></ol> <p><code>auto</code>用于计算对应方向所获得的剩余空间大小。</p> <p><strong>实现右对齐效果，margin属性的auto计算就是为块级元素左中右对齐而设计的，和内联元素使用text-align控制左中右对齐相对应。</strong></p> <p><strong>居中对齐左右同时auto计算即可</strong></p> <p><strong>绝对定位垂直水平居中</strong></p> <h4 id="margin无效情形解析"><a href="#margin无效情形解析" aria-hidden="true" class="header-anchor">#</a> <code>margin</code>无效情形解析</h4> <ol><li><code>display</code>计算值<code>inline</code>的非替换元素的垂直<code>margin</code>无效。</li> <li>表格中<code>tr</code>和<code>td</code>元素或设置<code>display</code>计算值是<code>table-cell</code>或<code>table-row</code>的元素的<code>margin</code>都是无效。</li> <li><code>margin</code>合并的时候，更改<code>margin</code>值可能没有效果。</li> <li>绝对定位元素非定位方位的<code>margin</code>值无效。绝对定位元素的渲染是独立的，所以设置了<code>top</code>、<code>left</code>方位，再设置<code>margin-right</code>无效。</li> <li>定高容器的子元素的<code>margin-bottom</code>或定宽容器的子元素的<code>margin-right</code>的定位失效。<strong>使用margin属性改变自身的位置，必须是和当前元素定位方向一样的margin属性，否则margin只能影响后面的元素或父元素。</strong></li> <li>鞭长莫及导致的<code>margin</code>无效。</li> <li>内联特性导致的<code>margin</code>无效。</li></ol> <h3 id="功勋卓著的border属性"><a href="#功勋卓著的border属性" aria-hidden="true" class="header-anchor">#</a> 功勋卓著的<code>border</code>属性</h3> <h4 id="为什么border-width不支持百分比值"><a href="#为什么border-width不支持百分比值" aria-hidden="true" class="header-anchor">#</a> 为什么<code>border-width</code>不支持百分比值</h4> <p><code>border-width</code>支持关键字，<code>thin</code>、<code>medium</code></p> <h4 id="了解各种border-style类型"><a href="#了解各种border-style类型" aria-hidden="true" class="header-anchor">#</a> 了解各种<code>border-style</code>类型</h4> <ol><li><code>border-style:none</code>，默认值</li> <li><code>border-style:solid</code>，实线边框</li> <li><code>border-style:dashed</code>，虚线边框</li> <li><code>border-style:dotted</code>，点线边框</li> <li><code>border-style:double</code>，双线边框</li> <li>其他<code>border-style</code>类型，<code>inset</code>内凹，<code>outset</code>外凸，<code>groove</code>沟槽，<code>ridge</code>山脊</li></ol> <h4 id="border-color和color"><a href="#border-color和color" aria-hidden="true" class="header-anchor">#</a> <code>border-color</code>和<code>color</code></h4> <p><code>border-color</code>默认颜色就是<code>color</code>色值。</p> <h4 id="border与透明边框技巧"><a href="#border与透明边框技巧" aria-hidden="true" class="header-anchor">#</a> <code>border</code>与透明边框技巧</h4> <p><strong>1. 右下方background定位技巧</strong></p> <p>方法一：<strong>使用透明边框</strong></p> <div class="language- extra-class"><pre class="language-text"><code>.box {
    border: 50px solid transparent;
    background-position: 100% 50%;
}
</code></pre></div><p><strong>2. 增加点击区域大小</strong></p> <p><strong>3. 三角等图形绘制</strong></p> <div class="language- extra-class"><pre class="language-text"><code>.box {
    width: 0;
    border: 10px solid;
    border-color: #f30 transparent transparent;
}  
&lt;div class=&quot;box&quot;&gt;&lt;/div&gt; 
</code></pre></div><h4 id="border与图形构建"><a href="#border与图形构建" aria-hidden="true" class="header-anchor">#</a> <code>border</code>与图形构建</h4> <h4 id="border等高布局技术"><a href="#border等高布局技术" aria-hidden="true" class="header-anchor">#</a> <code>border</code>等高布局技术</h4> <p><strong>父容器不能使用overflow:hidden;清除浮动影响，因为溢出隐藏是基于padding box的，如果设置了则左浮动的导航列表元素就会被隐藏掉。</strong></p> <h2 id="内联元素与流"><a href="#内联元素与流" aria-hidden="true" class="header-anchor">#</a> 内联元素与流</h2> <h3 id="字母x"><a href="#字母x" aria-hidden="true" class="header-anchor">#</a> 字母<code>x</code></h3> <h4 id="字母x与css世界的基线"><a href="#字母x与css世界的基线" aria-hidden="true" class="header-anchor">#</a> 字母<code>x</code>与CSS世界的基线</h4> <p>字母<code>x</code>的下边缘（线）就是<strong>基线</strong>。</p> <h4 id="字母x与css中的x-height"><a href="#字母x与css中的x-height" aria-hidden="true" class="header-anchor">#</a> 字母<code>x</code>与CSS中的<code>x-height</code></h4> <p><code>x-height</code>指的是字母<code>x</code>的高度。</p> <p><code>vertical-align:middle;</code>的<code>middle</code>指的是基线网上<code>1/2 x-height</code>高度。</p> <h4 id="字母x与css中的ex"><a href="#字母x与css中的ex" aria-hidden="true" class="header-anchor">#</a> 字母<code>x</code>与CSS中的<code>ex</code></h4> <p><code>ex</code>是CSS中的一个相对单位，指的是小写字母<code>x</code>的高度，即<code>x-height</code>。</p> <p><code>ex</code>的作用是<strong>不受字体和字号影响的内联元素的垂直居中对齐效果</strong>。</p> <p>内联元素默认是基线对齐，而基线就是<code>x</code>的底部，而<code>1ex</code>就是一个<code>x</code>的高度。</p> <p><strong>文字与小三角图标</strong></p> <h3 id="内联元素的基石line-height"><a href="#内联元素的基石line-height" aria-hidden="true" class="header-anchor">#</a> 内联元素的基石<code>line-height</code></h3> <h4 id="内联元素的高度之本——line-height"><a href="#内联元素的高度之本——line-height" aria-hidden="true" class="header-anchor">#</a> 内联元素的高度之本——<code>line-height</code></h4> <p>**<code>div</code>高度是行高<code>line-height</code>决定的，而非文字。**对于非替换元素的纯内联元素，其可视高度完全由<code>line-height</code>决定。</p> <p>行距=<code>line-height</code>-<code>font-size</code>。<code>em</code>是一个相对<code>font-size</code>大小的CSS单位，因此<code>1em</code>等于当前一个<code>font-size</code>大小。</p> <p><code>line-height</code>不会影响替换元素。图片为内联元素，会构成一个“行框盒子”，而在HTML5下，每一个“行框盒子”的前面都是一个宽度为<code>0</code>的“幽灵空白节点”，其内联特性表现和普通字符完全一样。</p> <p>对于块级元素，<code>line-height</code>对其本身没有任何作用，改变<code>line-height</code>，块级元素的高度跟着变化实际上是<strong>通过改变块级元素里面内联元素占据的高度实现。</strong></p> <h4 id="为什么line-height可以让内联元素“垂直居中”"><a href="#为什么line-height可以让内联元素“垂直居中”" aria-hidden="true" class="header-anchor">#</a> 为什么<code>line-height</code>可以让内联元素“垂直居中”</h4> <p><strong>行高实现多行文本或图片等替换元素的垂直居中效果</strong></p> <h4 id="深入line-height的各类属性值"><a href="#深入line-height的各类属性值" aria-hidden="true" class="header-anchor">#</a> 深入<code>line-height</code>的各类属性值</h4> <p><code>line-height</code>的默认值是<code>normal</code>，还支持数值、百分比值以及长度值。</p> <p>在实际开发中，需要对<code>line-height</code>的默认值进行重置：</p> <ol><li><strong>数值</strong>。计算方法<code>line-height</code>=1.5*<code>font-size</code></li> <li><strong>百分比值</strong>。<code>line-height</code>=150%*<code>font-size</code></li> <li><strong>长度值</strong>。<code>line-height</code>=1.5*<code>font-size</code></li></ol> <ul><li>制作一个图文内容比较多的网站，使用<strong>数值</strong>作为单位，<code>line-height</code>值可以设置在<code>1.6~1.8</code>。</li> <li>偏重布局结构的网站，使用<strong>长度值</strong>或<strong>数值</strong>都可以，<code>line-height</code>值可以设置在<code>20px</code>。</li></ul> <h4 id="内联元素line-height的“大值特性”"><a href="#内联元素line-height的“大值特性”" aria-hidden="true" class="header-anchor">#</a> 内联元素<code>line-height</code>的“大值特性”</h4> <p><strong>无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定，称之为内联元素line-height的“大值特性”</strong></p> <p>每个内联盒子外层都有一个看不见的<strong>行框盒子</strong>，在每个<strong>行框盒子</strong>前面都有一个<strong>宽度为0的具有该元素的字体和行高属性的看不见的幽灵空白节点</strong>。</p> <h4 id="line-height的好朋友vertical-align"><a href="#line-height的好朋友vertical-align" aria-hidden="true" class="header-anchor">#</a> <code>line-height</code>的好朋友<code>vertical-align</code></h4> <p>凡是<code>line-height</code>起作用的地方<code>vertical-align</code>也一定起作用。</p> <h4 id="vertical-align家族基本认识"><a href="#vertical-align家族基本认识" aria-hidden="true" class="header-anchor">#</a> <code>vertical-align</code>家族基本认识</h4> <p><code>vertical-align</code>属性值分为以下4类：</p> <ol><li><strong>线类</strong>。<code>baseline</code>默认值、<code>top</code>、<code>middle</code>、<code>bottom</code></li> <li><strong>文本类</strong>。<code>text-top</code>、<code>text-bottom</code></li> <li><strong>上标下标类</strong>。<code>sub</code>、<code>super</code></li> <li><strong>数值百分比类</strong>。<code>20px</code>、<code>2em</code>、<code>20%</code>等，正值往上偏移，负值往下偏移。</li></ol> <p><code>vertical-align</code>的默认值是<code>baseline</code>，即基线对齐，而基线的定义是字母<code>x</code>的下边缘。因此，内联元素默认都是沿着字母<code>x</code>的下边缘对齐。</p> <p><code>margin/padding</code>是相对于宽度计算，<code>line-height</code>是相对于<code>font-size</code>计算，<code>vertical-align</code>属性的百分比值是相对于<code>line-height</code>计算。</p> <h4 id="vertical-align作用前提"><a href="#vertical-align作用前提" aria-hidden="true" class="header-anchor">#</a> <code>vertical-align</code>作用前提</h4> <p><code>vertical-align</code>作用前提条件：<strong>只能应用于内联元素以及display值为table-cell的元素</strong>。也就是只能作用在<code>display</code>计算值为<code>inline</code>、<code>inline-block</code>、<code>inline-table</code>、<code>inline-cell</code>的元素上。</p> <p><strong>块级元素不支持。浮动元素和绝对定位会让元素块状化，从而导致vertical-align不起作用。</strong></p> <h4 id="vertical-align和line-height之间的关系"><a href="#vertical-align和line-height之间的关系" aria-hidden="true" class="header-anchor">#</a> <code>vertical-align</code>和<code>line-height</code>之间的关系</h4> <p><strong>解决图片底部留有间隙的问题</strong></p> <p>消除间隙的方法，从<strong>幽灵空白节点</strong>、<code>line-height</code>和<code>vertical-align</code>入手：</p> <ol><li><strong>图片块状化</strong>。</li> <li>**容器<code>line-height</code>足够小。**比如容器设置<code>line-height:0;</code></li> <li><strong>容器font-size足够小</strong>。</li> <li><strong>图片设置其他vertical-align属性值</strong>。间隙产生的原因之一就是<strong>基线对齐</strong>，所以设置<code>vertical-align</code>的值为<code>top/bottom/middle</code>其中一个。</li></ol> <h3 id="深入理解vertical-align线性类属性值"><a href="#深入理解vertical-align线性类属性值" aria-hidden="true" class="header-anchor">#</a> 深入理解<code>vertical-align</code>线性类属性值</h3> <h4 id="_1-inline-block与baseline"><a href="#_1-inline-block与baseline" aria-hidden="true" class="header-anchor">#</a> 1. <code>inline-block</code>与<code>baseline</code></h4> <p><strong>一个inline-block元素，如果里面没有内联元素，或者overflow:visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。</strong></p> <p>没有内联元素，基线就是容器的<code>margin</code>下边缘，即下边框下面的位置；有内联元素，基线就是字符的下边缘。</p> <p>字符实际占据的高度是由<code>line-height</code>决定，当<code>line-height</code>变为<code>0</code>时，字符占据的高度也是<code>0</code>，此时高度的起始位置就变成字符内容区域的垂直中心位置。</p> <p><strong>解决间隙问题的方法</strong></p> <ol><li>改变占位<code>&lt;i&gt;</code>元素的基线；</li> <li>改造<strong>幽灵空白节点</strong>的基线位置；</li> <li>使用其他<code>vertical-align</code>对齐方式。</li></ol> <p><strong>改造幽灵空白节点的基线位置可以使用font-size，当字体足够小时（设为0），基线和中线会重合在一起。</strong></p> <blockquote><p><strong>基于20px图标对齐的处理技巧</strong></p></blockquote> <ol><li><strong>图标高度和当前行高都是20px</strong>。</li> <li><strong>图标标签里面永远有字符</strong>。借助<code>:before</code>和<code>:after</code>伪元素生成一个空格字符。</li> <li><strong>图标CSS不适用overflow:hidden;保证基线为里面字符的基线，但是需要让里面潜在的字符不可见</strong>。</li></ol> <h4 id="_2-vertical-align-top-bottom"><a href="#_2-vertical-align-top-bottom" aria-hidden="true" class="header-anchor">#</a> 2. <code>vertical-align:top/bottom</code></h4> <ul><li>内联元素：元素底部和当前行框盒子的顶部对齐。</li> <li><code>table-cell</code>元素：元素底<code>padding</code>边缘和表格行的顶部对齐。</li></ul> <h4 id="_3-vertical-align-middle与近似垂直居中"><a href="#_3-vertical-align-middle与近似垂直居中" aria-hidden="true" class="header-anchor">#</a> 3. <code>vertical-align:middle</code>与近似垂直居中</h4> <ul><li>内联元素：元素的垂直中心点和行框盒子相对于外面的表格行居中对齐。</li> <li><code>table-cell</code>元素：单元格填充盒子相对于外面的表格行居中对齐。</li></ul> <h3 id="深入理解vertical-align文本类属性值"><a href="#深入理解vertical-align文本类属性值" aria-hidden="true" class="header-anchor">#</a> 深入理解<code>vertical-align</code>文本类属性值</h3> <ul><li><code>vertical-align:text-top</code>：盒子的顶部和父级内容区域的顶部对齐。</li> <li><code>vertical-align:text-bottom</code>：盒子的底部和父级内容区域的底部对齐。</li></ul> <ol><li>文本类属性值的垂直对齐与左右文字大小和高度都没有关系，而所有线性类属性值的定位都会受到兄弟内联元素的影响。</li> <li>文本类属性值的垂直对齐可以像素级精确控制。如果是图文对齐，可以通过改变父元素的<code>font-size</code>大小精确控制对齐位置；如果是文字之间对齐，可以通过改变文字的<code>line-height</code>，也就是改变元素的高度（上下边缘位置）精确控制对齐位置。</li></ol> <h3 id="简单了解深入理解vertical-align线性类属性值上标下标类属性值"><a href="#简单了解深入理解vertical-align线性类属性值上标下标类属性值" aria-hidden="true" class="header-anchor">#</a> 简单了解深入理解<code>vertical-align</code>线性类属性值上标下标类属性值</h3> <p><code>vertical-align</code>线性类属性值上标下标类属性值指的是<code>sub</code>和<code>super</code>两个值。</p> <ul><li><code>vertical-align:super</code>：提高盒子的基线到父级合适的上标基线位置。</li> <li><code>vertical-align:sub</code>：降低盒子的基线到父级合适的下标基线位置。</li></ul> <h4 id="无处不在的vertical-align"><a href="#无处不在的vertical-align" aria-hidden="true" class="header-anchor">#</a> 无处不在的<code>vertical-align</code></h4> <h4 id="基于vertical-align属性的水平垂直居中弹框"><a href="#基于vertical-align属性的水平垂直居中弹框" aria-hidden="true" class="header-anchor">#</a> 基于<code>vertical-align</code>属性的水平垂直居中弹框</h4> <blockquote><p><strong>使用纯CSS实现大小不固定的弹框永远居中的效果，如果伪元素换成普通元素，兼容IE7。</strong></p></blockquote> <p>**<code>vertical-align:middle</code>**定义是元素的中线和字符<code>x</code>中心点对齐。</p> <ol><li><code>font-size</code>设置为<code>0</code>，<code>x</code>中心点位置是<code>.container</code>的上边缘，高度<code>100%</code>宽度<code>0</code>的伪元素和这个中心点对齐。CSS中默认是左上方排列对齐，所以这个伪元素和原本在容器上边缘的<code>x</code>中心点一起往下移动了半个容器高度，就是此时<code>x</code>中心点在 容器的垂直中心线上。</li> <li>弹框元素<code>.dialog</code>设置<code>vertical-align:middle;</code>。根据定义，弹框的垂直中心位置和<code>x</code>中心点位置对齐，此时<code>x</code>中心点在容器的垂直中心位置，<code>.dialog</code>元素和容器垂直中心位置对齐，从而实现垂直居中效果。</li></ol> <h2 id="流的破坏与保护"><a href="#流的破坏与保护" aria-hidden="true" class="header-anchor">#</a> 流的破坏与保护</h2> <h3 id="魔鬼属性float"><a href="#魔鬼属性float" aria-hidden="true" class="header-anchor">#</a> 魔鬼属性<code>float</code></h3> <h4 id="float的本质与特性"><a href="#float的本质与特性" aria-hidden="true" class="header-anchor">#</a> <code>float</code>的本质与特性</h4> <h5 id="float浮动属性让父元素高度坍塌的原因就是为了实现文字环绕效果。"><a href="#float浮动属性让父元素高度坍塌的原因就是为了实现文字环绕效果。" aria-hidden="true" class="header-anchor">#</a> <strong>float浮动属性让父元素高度坍塌的原因就是为了实现文字环绕效果</strong>。</h5> <p><code>float</code>自身特性：</p> <ul><li>包裹性；</li> <li>块状化并格式化上下文；</li> <li>破坏文档流；</li> <li>没有任何<code>margin</code>合并。</li></ul> <p>包裹性，由<strong>包裹</strong>和<strong>自适应性</strong>两部分组成。</p> <ol><li><strong>包裹</strong>。浮动元素父元素宽度<code>200px</code>，子元素是一个宽度<code>128px</code>宽度的图片，则此时浮动元素宽度表现为<strong>包裹</strong>，就是里面图片的宽度<code>128px</code>。</li></ol> <p><a href="https://camo.githubusercontent.com/fa61b1e2fc2c11b76079e67444c106a3707b53ba/68747470733a2f2f692e696d6775722e636f6d2f51434e424478732e6a7067" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/fa61b1e2fc2c11b76079e67444c106a3707b53ba/68747470733a2f2f692e696d6775722e636f6d2f51434e424478732e6a7067" alt="img"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ol><li><strong>自适应性</strong>。</li></ol> <p><strong>块状化</strong>，元素一旦<code>float</code>的属性值不为<code>none</code>，则其<code>display</code>计算值为<code>block</code>或<code>table</code>。<strong>text-align对浮动元素无效。</strong></p> <table><thead><tr><th>设定值</th> <th>计算值</th></tr></thead> <tbody><tr><td><code>inline</code></td> <td><code>block</code></td></tr> <tr><td><code>inline-block</code></td> <td><code>block</code></td></tr> <tr><td><code>inline-table</code></td> <td><code>table</code></td></tr> <tr><td><code>table-row</code></td> <td><code>block</code></td></tr> <tr><td><code>table-row-group</code></td> <td><code>block</code></td></tr> <tr><td><code>table-column</code></td> <td><code>block</code></td></tr> <tr><td><code>table-columngroup</code></td> <td><code>block</code></td></tr> <tr><td><code>table-cell</code></td> <td><code>block</code></td></tr> <tr><td><code>table-caption</code></td> <td><code>block</code></td></tr> <tr><td><code>table-header-group</code></td> <td><code>block</code></td></tr> <tr><td><code>table-footer-group</code></td> <td><code>block</code></td></tr></tbody></table> <h4 id="float的作用机制"><a href="#float的作用机制" aria-hidden="true" class="header-anchor">#</a> <code>float</code>的作用机制</h4> <p><strong>文字环绕效果</strong>是由两个特性（<strong>父级高度坍塌</strong>和<strong>行框盒子区域限制</strong>）共同作用的结果，定高只能解决<strong>父级元素高度坍塌</strong>带来的影响，但是对<strong>行框盒子区域限制</strong>没有任何效果，结果导致的问题是浮动元素垂直区域一旦超出高度范围，或下面元素<code>margin-top</code>负值上偏移，就很容易使后面的元素发生“环绕效果”。</p> <h4 id="float更深入的作用机制"><a href="#float更深入的作用机制" aria-hidden="true" class="header-anchor">#</a> <code>float</code>更深入的作用机制</h4> <p><strong>浮动元素和内联元素在一行显示。</strong></p> <ul><li><strong>浮动锚点</strong>是<code>float</code>元素所在的<strong>流</strong>中的一个点，这个点本身并不浮动。其作用是产生<strong>行框盒子</strong>，因为<strong>浮动锚点</strong>表现如同一个空的内联元素，有内联元自然就有<strong>行框盒子</strong>。</li> <li><strong>浮动参考</strong>指的是浮动元素对齐参考的实体。</li></ul> <p><code>float</code>元素的<strong>浮动参考</strong>是<strong>行框盒子</strong>，也就是<code>float</code>元素在当前<strong>行框盒子</strong>内定位。</p> <h4 id="float与流体布局"><a href="#float与流体布局" aria-hidden="true" class="header-anchor">#</a> <code>float</code>与流体布局</h4> <h3 id="float的天然克星clear"><a href="#float的天然克星clear" aria-hidden="true" class="header-anchor">#</a> <code>float</code>的天然克星<code>clear</code></h3> <h4 id="什么是clear属性"><a href="#什么是clear属性" aria-hidden="true" class="header-anchor">#</a> 什么是<code>clear</code>属性</h4> <p><code>clear</code>专门用来处理<code>float</code>属性带来的高度坍塌等问题。</p> <div class="language- extra-class"><pre class="language-text"><code>clear: none | left | right | both
</code></pre></div><ul><li><code>none</code>：默认值，左右浮动</li> <li><code>left</code>：左侧抗浮动</li> <li><code>right</code>：右侧抗浮动</li> <li><code>both</code>：两侧抗浮动</li></ul> <p>实际应用中只使用<code>clear:both;</code>即可。</p> <h4 id="成事不足败事有余的clear"><a href="#成事不足败事有余的clear" aria-hidden="true" class="header-anchor">#</a> 成事不足败事有余的<code>clear</code></h4> <p><code>clear</code>属性只有块级元素才有效，而<code>:after</code>等伪元素默认都是内联水平，这就是伪元素清除浮动影响时需要设置<code>display</code>属性值的原因。</p> <p><code>clear:both</code>的作用本质是让自身不与<code>float</code>元素在一行显示，并不是真正意义上的清除浮动。</p> <ol><li>如果<code>clear:both;</code>元素前面的元素就是<code>float</code>元素，则<code>margin-top</code>负值即使设成<code>-9999px</code>，也没有效果。</li> <li><code>clear:both;</code>后面的元素依旧可能发生文字环绕的现象。</li></ol> <h3 id="css世界的结界——bfc"><a href="#css世界的结界——bfc" aria-hidden="true" class="header-anchor">#</a> CSS世界的结界——<strong>BFC</strong></h3> <h4 id="bfc的定义"><a href="#bfc的定义" aria-hidden="true" class="header-anchor">#</a> <strong>BFC</strong>的定义</h4> <p><strong>BFC</strong>称为<strong>块级格式化上下文</strong>。<strong>BFC</strong>元素不可能发生<code>margin</code>重叠，<code>margin</code>重叠会影响外面的元素；<strong>BFC</strong>元素也可以用来清除浮动的影响，如果不清楚，子元素浮动则会父元素高度坍塌，必然会影响后面元素布局和定位。</p> <p>何时会触发<strong>BFC</strong>，常见情况如下：</p> <ul><li><code>html</code>根元素；</li> <li><code>overflow</code>的值为<code>auto</code>、<code>scroll</code>或<code>hidden</code>；</li> <li><code>display</code>的值为<code>table-cell</code>、<code>table-caption</code>和<code>inline-block</code>中的任何一个；</li> <li><code>float</code>的值不为<code>none</code>；</li> <li><code>position</code>的值不为<code>relative</code>和<code>static</code>。</li></ul> <p>只要元素符合上面任意一个条件，就无须使用<code>clear:both;</code>属性去清除浮动的影响。</p> <h4 id="bfc与流体布局"><a href="#bfc与流体布局" aria-hidden="true" class="header-anchor">#</a> <strong>BFC</strong>与流体布局</h4> <p><strong>BFC</strong>的表现原则：具有<strong>BFC</strong>特性的元素的子元素不会受到外部元素的影响，也不会影响外部元素。普通流体元素在设置了<code>overflow:hidden;</code>后，会自动填满容器中除了浮动元素以外的剩余空间，形成自适应布局效果。</p> <div class="language- extra-class"><pre class="language-text"><code>img {
    float: left;
    margin-right: 10px;
}

.content {
    overflow: hidden;
}
</code></pre></div><p>基于<strong>BFC</strong>特性的自适应布局有如下优点：</p> <ol><li>自适应内容由于封闭更加健壮，容错性更强。内部设置<code>clear:both;</code>不会与<code>float</code>元素相互干扰而导致错位。</li> <li>自适应内容自动填充浮动以外区域，无需关心浮动元素宽度，可以整站大规模应用。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>.left {
    float: left;
}

.right {
    float: right;
}

.bfc {
    overflow: hidden;
}
</code></pre></div><ol><li><code>float:left;</code>。浮动元素本身<strong>BFC</strong>化，然而浮动元素具有破坏性和包裹性，失去了元素本身的流体自适应性，因此无法用来实现自动填满容器的自适应布局。</li> <li><code>position:absolute;</code>。脱离文档流，不容易操作。</li> <li><strong>overflow:hidden;块状元素的流体特性保存得很好，加上</strong>BFC<strong>的独立区域特性，而且从IE7开始就支持，兼容性很好。唯一的问题是容器盒子外的元素可能会被隐藏掉。</strong></li> <li><code>display:inline-block;</code></li> <li><code>display:table-cell</code></li> <li><code>display:table-row</code></li> <li><code>display:table-caption</code></li></ol> <p>总结上面的自适应布局设置，最佳实践如下：</p> <ol><li><code>overflow: auto/hidden;</code>，适用于IE7及以上版本浏览器；</li> <li><code>display: inline-block;</code>，适应于IE6和IE7;</li> <li><code>display: table-cell;</code>，适用于IE8及以上版本浏览器。</li></ol> <p>IE7及以上版本浏览器适配的自适应解决方案：</p> <ol><li>借助<code>overflow</code>属性，如下:</li></ol> <div class="language- extra-class"><pre class="language-text"><code>.lbf-content {
    overflow: hidden;
}
</code></pre></div><ol><li>融合<code>display: table-cell;</code>和<code>display: inline-block;</code>，如下：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>.lbf-content {
    display: table-cell;
    width: 9999px;
}
</code></pre></div><p><code>display: table-cell;</code>元素内连续英文字符无法换行的问题：</p> <div class="language- extra-class"><pre class="language-text"><code>.word-break {
    display: table;
    width: 100%;
    table-layout: fixed;
    word-break: break-all;
}
</code></pre></div><h3 id="最佳结界overflow"><a href="#最佳结界overflow" aria-hidden="true" class="header-anchor">#</a> 最佳结界<code>overflow</code></h3> <blockquote><p>要彻底清除浮动的影响，最适合的属性是<code>overflow</code>。<code>overflow:hidden;</code>声明不会影响元素原先的流体特性或宽度表现。</p></blockquote> <h3 id="overflow裁剪界线border-box"><a href="#overflow裁剪界线border-box" aria-hidden="true" class="header-anchor">#</a> <code>overflow</code>裁剪界线<code>border box</code></h3> <p>当子元素内容超出容器宽度高度限制的时候，剪裁的边界是<code>border box</code>的内边缘，而非<code>padding box</code>的内边缘。</p> <p>在实际项目开发时，要尽量避免滚动条容器设置<code>padding-bottom</code>值。</p> <h3 id="了解overflow-x和overflow-y"><a href="#了解overflow-x和overflow-y" aria-hidden="true" class="header-anchor">#</a> 了解<code>overflow-x</code>和<code>overflow-y</code></h3> <p>IE8以上浏览器，<code>overflow</code>增加了两个属性，<code>overflow-x</code>和<code>overflow-y</code>，分别表示单独控制水平或垂直方向上的剪裁规则。</p> <p>支持的属性值和<code>overflow</code>属性一模一样：</p> <ul><li><code>visible</code>：默认值</li> <li><code>hidden</code>：剪裁</li> <li><code>scroll</code>：滚动条</li> <li><code>auto</code></li></ul> <p><strong>不会出现一个方向溢出剪裁或滚动，另一个方向内容溢出显示的效果。</strong></p> <h3 id="overflow与滚动条"><a href="#overflow与滚动条" aria-hidden="true" class="header-anchor">#</a> <code>overflow</code>与滚动条</h3> <p>浏览器的滚动条：</p> <ol><li>默认滚动条来自<code>html</code>，而不是<code>body</code>标签。去除页面默认滚动条：</li></ol> <div class="language- extra-class"><pre class="language-text"><code>html {
    overflow: hidden;
}
</code></pre></div><p>在PC端，滚动条高度可以使用<code>document.documentElement.scrollTop</code>获取，但是在移动端，需要使用<code>document.body.scrollTop</code>获取。 2. 滚动条会占用容器的可用高度或宽度。</p> <p><strong>让页面滚动条不发生晃动的技巧</strong></p> <div class="language- extra-class"><pre class="language-text"><code>html {
    overflow-y: scroll;
}

:root {
    overflow-y: auto;
    overflow-x: hidden;
}

:root body {
    position: absolute;
}

body {
    width: 100%;
    overflow: hidden;
}
</code></pre></div><p>滚动条自定义效果：</p> <ul><li>整体部分：<code>::-webkit-scrollbar</code></li> <li>两端按钮：<code>::-webkit-scrollbar-button</code></li> <li>外层轨道：<code>::-webkit-scrollbar-track</code></li> <li>内层轨道：<code>::-webkit-scrollbar-track-piece</code></li> <li>滚动滑块：<code>::-webkit-scrollbar-thumb</code></li> <li>边角：<code>::-webkit-scrollbar-corner</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>::-webkit-scrollbar { /*血槽宽度*/
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-thumb { /*拖动条*/
    background-color: rgba(0, 0, 0, .3);
    border-radius: 6px;
}

::-webkit-scrollbar-track { /*背景槽*/
    background-color: #ddd;
    border-radius: 6px;
}
</code></pre></div><h3 id="依赖overflow的样式表现"><a href="#依赖overflow的样式表现" aria-hidden="true" class="header-anchor">#</a> 依赖<code>overflow</code>的样式表现</h3> <p>单行文字溢出<code>...</code>效果，需要使用到<code>overflow:hidden;</code>、<code>text-overflow:hidden;</code>，效果实现必需的3个声明如下：</p> <div class="language- extra-class"><pre class="language-text"><code>.ell {
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
}
</code></pre></div><p>最多显示2行内容，再多就打点的核心CSS代码：</p> <div class="language- extra-class"><pre class="language-text"><code>.ell-rows-2 {
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
}
</code></pre></div><h3 id="overflow与锚点定位"><a href="#overflow与锚点定位" aria-hidden="true" class="header-anchor">#</a> <code>overflow</code>与锚点定位</h3> <p>基于URL地址的锚链<code>location.hash</code>实现锚点跳转的方法有两种：</p> <ol><li><code>a</code>标签以及<code>name</code>属性</li> <li>使用标签的<code>id</code>属性</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;a href=&quot;#1&quot;&gt;发展历程&lt;/a&gt;
&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;
</code></pre></div><p><strong>1. 锚点定位行为的触发条件</strong></p> <ol><li>URL地址中的锚链与锚点元素对应并有交互行为；</li> <li>可<code>focus</code>的锚点元素处于<code>focus</code>状态。</li></ol> <p><strong>focus锚点定位</strong>指的是类似链接或按钮、输入框等可以被<code>focus</code>的元素在被<code>focus</code>时发生的页面重定位现象。</p> <p><strong>URL地址锚点定位</strong>是让元素定位在浏览器窗体的上边缘，而``focus<code>锚点定位</code>是让元素在浏览器窗体范围内显示即可。</p> <p><strong>2. 锚点定位作用的本质</strong></p> <p>锚点定位行为的发生，本质上是通过改变容器滚动高度或宽度来实现。改变了<code>scrollTop</code>或<code>scrollLeft</code>的值。</p> <p>处理列表部分区域正在浏览器外面依然会跳动的问题：</p> <div class="language- extra-class"><pre class="language-text"><code>$('label.click').removeAttribute('for').on('click', function () {
    $('.box').scrollTop(xxx);//滚动数值
});
</code></pre></div><p>基于父容器自身的<code>scrollTop</code>值改变来实现自定义滚动条效果。</p> <ol><li>实现简单，无须做边界判断。<code>container.scrollTop=99999;</code>，列表滚动就是<code>scrollTop</code>值，实时获取。</li> <li>可与原生的<code>scroll</code>事件天然继承，无缝对接。</li> <li>无须改变子元素的结构。</li></ol> <h3 id="float的兄弟position-absolute"><a href="#float的兄弟position-absolute" aria-hidden="true" class="header-anchor">#</a> <code>float</code>的兄弟<code>position:absolute</code></h3> <p>绝对定位<code>absolute</code>具有块状化，块状格式化上下文、包裹性和自适应性。自适应性的最大宽度由“包含块”决定。</p> <h3 id="absolute的包含块"><a href="#absolute的包含块" aria-hidden="true" class="header-anchor">#</a> <code>absolute</code>的包含块</h3> <p>普通元素的百分比宽度是相对于父元素的<code>content box</code>宽度计算，而绝对定位元素的宽度是相对于第一个<code>position</code>不为<code>static</code>的祖先元素计算的。</p> <ol><li><p>根元素<code>html</code>被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</p></li> <li><p>对于其他元素，如果该元素的<code>position</code>是<code>relative</code>或<code>static</code>，则“包含块”由其最近的块容器祖先盒子的<code>content box</code>边界组成。</p></li> <li><p>如果元素<code>position:fixed;</code>，则“包含块”是“初始包含块”。</p></li> <li><p>如果元素</p> <div class="language- extra-class"><pre class="language-text"><code>position:absolute;
</code></pre></div><p>，则“包含块”由最近的</p> <div class="language- extra-class"><pre class="language-text"><code>position
</code></pre></div><p>不为</p> <div class="language- extra-class"><pre class="language-text"><code>static
</code></pre></div><p>的祖先元素建立，具体方式如下：</p> <p>如果该祖先元素是纯<code>inline</code>元素，则规则略复杂：</p> <ul><li>给内联元素的前后各生成一个宽度为<code>0</code>的内联盒子，则这两个内联盒子的<code>padding box</code>外面的包围盒子就是内联元素的“包含块”。</li> <li>如果该内联元素被跨行分割，则<strong>包含块</strong>是未定义的。 <strong>否则，“包含块”由该祖先的padding box边界组成。</strong></li></ul></li></ol> <p>和常规元素相比，绝对定位元素的<strong>包含块</strong>有3个明显的差异：</p> <ol><li>内联元素也可以作为<strong>包含块</strong>所在的元素；</li> <li><strong>包含块</strong>所在的元素不是父级块元素，而是最近的<code>position</code>不为<code>static</code>的祖先元素或根元素；</li> <li>边界是<code>padding box</code>而不是<code>content box</code>。</li></ol> <p><strong>内联元素的“包含块”是由“生成的”前后内联盒子决定，与里面的内联盒子细节没有任何关系。</strong></p> <blockquote><p><code>height:100%;</code>是第一个具有定位属性值得祖先元素的高度，而<code>height:inherit;</code>则是单纯的父元素的高度继承。</p></blockquote> <h3 id="具有相对特性的无依赖absolute绝对定位"><a href="#具有相对特性的无依赖absolute绝对定位" aria-hidden="true" class="header-anchor">#</a> 具有相对特性的无依赖<code>absolute</code>绝对定位</h3> <p><strong>1. 各类图标定位</strong></p> <p><strong>2. 超越常规布局的排版</strong></p> <p><strong>3. 下拉列表的定位</strong></p> <p><strong>4. 占位符效果模拟</strong></p> <p><strong>5. 进一步深入“无依赖绝对定位”</strong></p> <h3 id="absolute与text-align"><a href="#absolute与text-align" aria-hidden="true" class="header-anchor">#</a> <code>absolute</code>与<code>text-align</code></h3> <p><code>absolute</code>元素的<code>display</code>计算值是块状的，<code>text-align</code>不会起作用。</p> <h3 id="absolute与overflow"><a href="#absolute与overflow" aria-hidden="true" class="header-anchor">#</a> <code>absolute</code>与<code>overflow</code></h3> <p>如果<code>overflow</code>不是定位元素，同时绝对定位元素和<code>overflow</code>容器之间也没有定位元素，则<code>overflow</code>无法对<code>absolute</code>元素进行裁剪。<strong>overflow元素父级是定位元素也不会裁剪。</strong></p> <ol><li><code>overflow</code>属性所在的元素同时也是定位元素，里面的绝对定位元素会被裁剪；</li> <li><code>overflow</code>元素和绝对定位元素之间有定位元素，也会被裁剪。</li> <li><code>overflow</code>属性值不是<code>hidden</code>，而是<code>auto</code>或<code>scroll</code>，即使绝对定位元素高度比<code>overflow</code>元素高度大，也不会出现滚动条。</li></ol> <h3 id="absolute与clip"><a href="#absolute与clip" aria-hidden="true" class="header-anchor">#</a> <code>absolute</code>与<code>clip</code></h3> <p><code>clip</code>属性要起作用，元素必须是绝对定位<code>absolute</code>或固定定位<code>fixed</code>。</p> <p><code>clip</code>属性语法：<code>clip: rect(top right bottom left)</code></p> <h3 id="重新认识的clip属性"><a href="#重新认识的clip属性" aria-hidden="true" class="header-anchor">#</a> 重新认识的<code>clip</code>属性</h3> <p><strong>1. fixed固定定位的剪裁</strong></p> <div class="language- extra-class"><pre class="language-text"><code>.fixed-clip {
    position: fixed;
    clip: rect(30px 200px 200px 20px);
}
</code></pre></div><p><strong>2. 最佳可访问性隐藏</strong></p> <p>最佳可访问性隐藏指的是视觉上看不见，但是辅助设备能够进行识别和访问。</p> <div class="language- extra-class"><pre class="language-text"><code>.logo h1 {
    position: absolute;
    clip: rect(0 0 0 0);
}
&lt;a href=&quot;/&quot; class=&quot;logo&quot;&gt;
    &lt;h1&gt;我是标题&lt;/h1&gt;
&lt;/a&gt;
</code></pre></div><h3 id="深入了解clip的渲染"><a href="#深入了解clip的渲染" aria-hidden="true" class="header-anchor">#</a> 深入了解<code>clip</code>的渲染</h3> <p>clip隐藏仅仅是决定了哪部分是可见的，非可见部分无法响应点击事件，虽然视觉上隐藏，但是元素的尺寸依旧是原来的尺寸。</p> <h3 id="absolute的流体特性"><a href="#absolute的流体特性" aria-hidden="true" class="header-anchor">#</a> <code>absolute</code>的流体特性</h3> <h4 id="当absolute遇到left-top-right-bottom属性"><a href="#当absolute遇到left-top-right-bottom属性" aria-hidden="true" class="header-anchor">#</a> 当<code>absolute</code>遇到<code>left/top/right/bottom</code>属性</h4> <p>当<code>absolute</code>遇到<code>left/top/right/bottom</code>属性时，<code>absolute</code>元素才真正变成绝对定位元素。</p> <h4 id="absolute的流体特性-2"><a href="#absolute的流体特性-2" aria-hidden="true" class="header-anchor">#</a> <code>absolute</code>的流体特性</h4> <p>当一个绝对定位元素，其对立定位方向属性同时具有定位数值时，就会发生流体特性。</p> <p><strong>普通元素流体特性只有水平方向（默认），但是绝对定位元素可以让垂直方向和水平方向同时保持流动性。</strong></p> <h4 id="absolute的margin-auto居中"><a href="#absolute的margin-auto居中" aria-hidden="true" class="header-anchor">#</a> <code>absolute</code>的<code>margin:auto</code>居中</h4> <div class="language- extra-class"><pre class="language-text"><code>.box {
    width: 200px;
    height: 200px;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}
</code></pre></div><h3 id="position-relative才是大哥"><a href="#position-relative才是大哥" aria-hidden="true" class="header-anchor">#</a> <code>position:relative</code>才是大哥</h3> <h4 id="relative对absolute的限制"><a href="#relative对absolute的限制" aria-hidden="true" class="header-anchor">#</a> <code>relative</code>对<code>absolute</code>的限制</h4> <h4 id="relative与定位"><a href="#relative与定位" aria-hidden="true" class="header-anchor">#</a> <code>relative</code>与定位</h4> <p><code>relative</code>与定位特性：一是相对自身，二是无侵入（当<code>relative</code>进行定位偏移时，不会影响周围元素的布局）。</p> <p><code>relative</code>定位：相对定位元素的<code>left/top/right/bottom</code>百分比值是相对于 包含块计算，而非自身。</p> <p><code>top/bottom</code>垂直方向的百分比值计算和<code>height</code>百分比值一样，都是相对于高度计算。</p> <p>当相对定位元素同时应用对立方向定位值，<code>top/bottom</code>和<code>left/right</code>同时使用时，其表现和绝对定位差异很大，只有一个方向的定位属性起作用。</p> <h4 id="relative的最小化影响原则"><a href="#relative的最小化影响原则" aria-hidden="true" class="header-anchor">#</a> <code>relative</code>的最小化影响原则</h4> <ol><li>尽量不适用<code>relative</code>，定位某元素，可以使用<strong>无依赖的绝对定位</strong>；</li> <li>如果需要使用<code>relative</code>，则该<code>relative</code>需要最小化。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>&lt;div&gt;
    &lt;div style=&quot;position:relative;&quot;&gt;
        &lt;img src=&quot;1.jpg&quot; alt=&quot;&quot; style=&quot;position: absolute;top: 0;right: 0;&quot;&gt;
    &lt;/div&gt;
    &lt;p&gt;内容1&lt;/p&gt;
    &lt;p&gt;内容2&lt;/p&gt;
&lt;/div&gt;
</code></pre></div><h3 id="强悍的position-fixed固定定位"><a href="#强悍的position-fixed固定定位" aria-hidden="true" class="header-anchor">#</a> 强悍的<code>position:fixed</code>固定定位</h3> <h4 id="position-fixed不一样的“包含块”"><a href="#position-fixed不一样的“包含块”" aria-hidden="true" class="header-anchor">#</a> <code>position:fixed</code>不一样的“包含块”</h4> <p><code>position:fixed</code>固定定位元素的<strong>包含块</strong>是根元素。唯一可以限制固定定位元素的是<code>&lt;html&gt;</code>根元素。<code>relative</code>对<code>fixed</code>定位没有任何限制作用。</p> <h4 id="position-fixed的absolute模拟"><a href="#position-fixed的absolute模拟" aria-hidden="true" class="header-anchor">#</a> <code>position:fixed</code>的<code>absolute</code>模拟</h4> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;page&quot;&gt;固定定位元素&lt;/div&gt;
&lt;div class=&quot;fixed&quot;&gt;&lt;/div&gt;
html, body {
    height: 100%;
    overflow: hidden;
}
.page {
    height: 100%;
    overflow: auto;
}
.fixed {
    position: absolute;
}
</code></pre></div><h4 id="position-fixed与背景锁定"><a href="#position-fixed与背景锁定" aria-hidden="true" class="header-anchor">#</a> <code>position:fixed</code>与背景锁定</h4> <h2 id="层叠规则"><a href="#层叠规则" aria-hidden="true" class="header-anchor">#</a> 层叠规则</h2> <h3 id="z-index"><a href="#z-index" aria-hidden="true" class="header-anchor">#</a> <code>z-index</code></h3> <p><code>z-index</code>属性只有和定位元素在一起时才会起作用，可以是正数或负数。</p> <h3 id="层叠上下文和层叠水平"><a href="#层叠上下文和层叠水平" aria-hidden="true" class="header-anchor">#</a> 层叠上下文和层叠水平</h3> <h3 id="理解元素的层叠顺序（从上至下）"><a href="#理解元素的层叠顺序（从上至下）" aria-hidden="true" class="header-anchor">#</a> 理解元素的层叠顺序（从上至下）</h3> <ol><li>（<strong>装饰</strong>）正<code>z-index</code>，位置在最下面，特指层叠上下文元素的边框和背景色</li> <li><code>z-index:auto</code>或看成<code>z-index:0</code>，层叠水平一样</li> <li>（<strong>内容</strong>）<code>inline</code>水平盒子，指的是包括<code>inline/inline-block/inline-table</code>元素的层叠顺序，都是同等级别</li> <li>（<strong>布局</strong>）<code>float</code>浮动盒子</li> <li>（<strong>布局</strong>）<code>block</code>块状水平盒子</li> <li>负<code>z-index</code></li> <li>层叠上下文<code>background/border</code></li></ol> <h3 id="牢记层叠准则"><a href="#牢记层叠准则" aria-hidden="true" class="header-anchor">#</a> 牢记层叠准则</h3> <p>层叠领域的黄金准则。当元素发生层叠时，其覆盖关系遵循下面两条准则：</p> <ol><li><strong>谁大谁上</strong>：层叠水平值大的在上面；</li> <li><strong>后来居上</strong>：当元素的层叠水平一致、层叠顺序相同时，处于后面的元素会覆盖前面的元素。</li></ol> <h3 id="深入了解层叠上下文"><a href="#深入了解层叠上下文" aria-hidden="true" class="header-anchor">#</a> 深入了解层叠上下文</h3> <h4 id="特性"><a href="#特性" aria-hidden="true" class="header-anchor">#</a> 特性</h4> <p>层叠上下文元素有如下特性：</p> <ul><li>层叠水平要比普通元素高</li> <li>可以阻断元素的混合模式</li> <li>可以嵌套，内部层叠上下文及其子元素均受制于外部的“层叠上下文”</li> <li>每个层叠上下文和兄弟元素独立，当进行层叠变化或渲染时，只需要考虑后代元素</li> <li>当发生层叠时，整个元素被认为是在父层叠上下文的层叠顺序中</li></ul> <h4 id="创建"><a href="#创建" aria-hidden="true" class="header-anchor">#</a> 创建</h4> <p><strong>1. 根层叠上下文</strong></p> <p>根层叠上下文指的是页面根元素<code>html</code>。</p> <p><strong>2. 定位元素和传统层叠上下文</strong></p> <p>对于<code>position</code>值为<code>relative/absolute</code>以及Firefox/IE浏览器下含有<code>position:fixed</code>声明的定位元素，当其<code>z-index</code>值不是<code>auto</code>时，会创建层叠上下文。</p> <blockquote><p>当<code>z-index:auto</code>时，遵循黄金准则的第一条<strong>谁大谁上</strong>；当<code>z-index</code>为具体数值时，按照父级的大小进行层叠排列；当<code>z-index</code>为具体数值，且父级层叠水平/顺序一致，遵循<strong>后来居上</strong>。</p></blockquote> <p><strong>3. CSS3层叠上下文</strong></p> <ol><li>元素为<code>flex</code>布局元素（父元素<code>display:flex|inline-flex</code>），同时<code>z-index</code>值不是<code>auto</code>。</li> <li>元素的<code>opacity</code>值不是<code>1</code>。</li> <li>元素的<code>transform</code>值不是<code>none</code>。</li> <li>元素的<code>filter</code>值不是<code>none</code>。</li></ol> <h3 id="层叠上下文与层叠顺序"><a href="#层叠上下文与层叠顺序" aria-hidden="true" class="header-anchor">#</a> 层叠上下文与层叠顺序</h3> <ol><li>如果层叠上下文不依赖<code>z-index</code>数值，则其层叠顺序是<code>z-index:auto</code>，可以看成<code>z-index:0</code>级别；</li> <li>如果层叠上下文元素依赖<code>z-index</code>数值，则其层叠顺序由<code>z-index</code>值决定。</li></ol> <p>元素成为定位元素，其<code>z-index</code>就会自动生效，此时其<code>z-index</code>默认是<code>auto</code>，也就是<code>0</code>级别，根据层叠顺序表，就会覆盖<code>inline/block/float</code>元素。不支持<code>z-index</code>的层叠上下文元素天然是<code>z-index:auto</code>级别，层叠上下文元素和定位元素是一个层叠顺序，当发生层叠时遵循<strong>后来居上</strong>准则。</p> <h3 id="z-index负值深入理解"><a href="#z-index负值深入理解" aria-hidden="true" class="header-anchor">#</a> <code>z-index</code>负值深入理解</h3> <p><code>z-index</code>负值具体作用：</p> <ol><li><p><strong>可访问性隐藏</strong>。<code>z-index</code>负值可以隐藏元素，只需要层叠上下文内的某一个父元素加背景色即可。<strong>优势如下</strong>：</p> <ul><li>它与<code>clip</code>隐藏相比，元素无须绝对定位，设置<code>position:relative</code>也可以隐藏；</li> <li>它对原来的布局以及元素的行为没有任何影响，而<code>clip</code>隐藏会导致控件<code>focus</code>的焦点发生细微的变化。</li></ul></li> <li><p><strong>IE8下的多背景模拟</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code>.box {
background-image: url(&quot;1.jpg&quot;);
position: relative;
z-index: 0;
}

.box:before,
.box:after {
content: '';
position: absolute;
z-index: -1;
}

.box:before {
background-image: url(&quot;2.jpg&quot;);
}

.box:after {
background-image: url(&quot;3.jpg&quot;);
}
</code></pre></div></li> <li><p><strong>定位在元素的后面</strong>。</p></li></ol> <h3 id="z-index准则"><a href="#z-index准则" aria-hidden="true" class="header-anchor">#</a> <code>z-index</code>准则</h3> <blockquote><p>对于非浮层元素，避免设置<code>z-index</code>值，<code>z-index</code>值不需要超过<code>2</code>。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>.box {
background-image: url(&quot;1.jpg&quot;);
position: relative;
z-index: 0;
}

.box:before,
.box:after {
content: '';
position: absolute;
z-index: -1;
}

.box:before {
background-image: url(&quot;2.jpg&quot;);
}

.box:after {
background-image: url(&quot;3.jpg&quot;);
}
</code></pre></div><h2 id="文本处理能力"><a href="#文本处理能力" aria-hidden="true" class="header-anchor">#</a> 文本处理能力</h2> <h3 id="line-height的另一个朋友font-size"><a href="#line-height的另一个朋友font-size" aria-hidden="true" class="header-anchor">#</a> <code>line-height</code>的另一个朋友<code>font-size</code></h3> <p><code>vertical-align</code>百分比值属性是相对于<code>line-height</code>计算，<code>line-height</code>的数值属性和百分比值都是相对于<code>font-size</code>计算。</p> <h3 id="font-size和vertical-align的隐秘故事"><a href="#font-size和vertical-align的隐秘故事" aria-hidden="true" class="header-anchor">#</a> <code>font-size</code>和<code>vertical-align</code>的隐秘故事</h3> <p><strong>原理：内联元素默认基线对齐，图片的基线是图片的下边缘，文字内容的基线是字符x下边缘。图片下边缘和文字字形边缘往上位置对齐。通过vertical-align:25%声明让图片的下边缘和中文汉字的中心线对齐。</strong></p> <h3 id="理解font-size与ex、em和rem的关系"><a href="#理解font-size与ex、em和rem的关系" aria-hidden="true" class="header-anchor">#</a> 理解<code>font-size</code>与<code>ex</code>、<code>em</code>和<code>rem</code>的关系</h3> <p>总结：<code>1em</code>的计算值等同当前元素所在的<code>font-size</code>计算值。</p> <h3 id="理解font-size的关键字属性值"><a href="#理解font-size的关键字属性值" aria-hidden="true" class="header-anchor">#</a> 理解<code>font-size</code>的关键字属性值</h3> <ol><li>相对尺寸关键字。<code>larger</code>、<code>smaller</code></li> <li>绝对尺寸关键字。<code>xx-large</code>、<code>x-large</code>、<code>large</code>、<code>medium</code>、<code>small</code>、<code>x-small</code>、<code>xx-small</code></li></ol> <ul><li>容器设置<code>font-size:medium</code>，此时这个局部展示区域的字号跟随浏览器的设置，默认计算值是<code>16px</code>。</li> <li>容器内的文字字号全部使用相对单位，如百分比值或<code>em</code>，然后基于<code>16px</code>进行转换。</li></ul> <h3 id="font-size-0与文本的隐藏"><a href="#font-size-0与文本的隐藏" aria-hidden="true" class="header-anchor">#</a> <code>font-size:0</code>与文本的隐藏</h3> <p>隐藏<code>logo</code>对应元素内的文字，除了<code>text-indent</code>缩进隐藏外，还可以使用以下方法：</p> <div class="language- extra-class"><pre class="language-text"><code>.logo {
    font-size: 0;
}
</code></pre></div><h3 id="字体属性家族font-family"><a href="#字体属性家族font-family" aria-hidden="true" class="header-anchor">#</a> 字体属性家族<code>font-family</code></h3> <p><code>font-family</code>支持两类属性值，一类是<strong>字体名</strong>，一类是<strong>字体族</strong>。</p> <p><strong>字体族</strong>：</p> <ul><li><code>serif</code>：衬线字体</li> <li><code>sans-serif</code>：无衬线字体</li> <li><code>monospace</code>：等宽字体</li> <li><code>cursive</code>：手写字体</li> <li><code>fantasy</code>：奇幻字体</li> <li><code>system-ui1</code>：系统UI字体</li></ul> <h3 id="了解衬线字体和无衬线字体"><a href="#了解衬线字体和无衬线字体" aria-hidden="true" class="header-anchor">#</a> 了解衬线字体和无衬线字体</h3> <p>字体分衬线字体和无衬线字体。</p> <ul><li>中文衬线字体<strong>宋体</strong>，英文衬线字体<strong>Times New Roman</strong>、<strong>Georgian</strong>等；</li> <li>无衬线字体，中文<strong>雅黑</strong>字体，英文<strong>Arial</strong>、<strong>Verdana</strong>、<strong>Tahoma</strong>、<strong>Helivetica</strong>、<strong>Calibra</strong>等。</li></ul> <h3 id="等宽字体的实践价值"><a href="#等宽字体的实践价值" aria-hidden="true" class="header-anchor">#</a> 等宽字体的实践价值</h3> <p><strong>1. 等宽字体与代码呈现</strong></p> <p><strong>2. 等宽字体与图形呈现</strong></p> <p><strong>3. ch单位与等宽字体布局</strong></p> <p><code>1ch</code>表示一个<code>0</code>字符的宽度。</p> <h3 id="中文字体和英文名称"><a href="#中文字体和英文名称" aria-hidden="true" class="header-anchor">#</a> 中文字体和英文名称</h3> <p><strong>Windows常见内置中文字体和对应英文名称。</strong></p> <table><thead><tr><th>字体中文名</th> <th>字体英文名</th></tr></thead> <tbody><tr><td>宋体</td> <td>SimSun</td></tr> <tr><td>黑体</td> <td>SimHei</td></tr> <tr><td>微软雅黑</td> <td>Microsoft Yahei</td></tr> <tr><td>微软正黑体</td> <td>Microsoft JhengHei</td></tr> <tr><td>楷体</td> <td>KaiTi</td></tr> <tr><td>新宋体</td> <td>NSimSun</td></tr> <tr><td>仿宋</td> <td>FangSong</td></tr></tbody></table> <h3 id="一些补充说明"><a href="#一些补充说明" aria-hidden="true" class="header-anchor">#</a> 一些补充说明</h3> <p>微软正黑体是一款全面支持ClearType技术的TrueType<strong>无衬线字体</strong>，用于繁体中文系统。</p> <h3 id="字体家族其他成员"><a href="#字体家族其他成员" aria-hidden="true" class="header-anchor">#</a> 字体家族其他成员</h3> <h4 id="font-weight"><a href="#font-weight" aria-hidden="true" class="header-anchor">#</a> <code>font-weight</code></h4> <h4 id="font-style"><a href="#font-style" aria-hidden="true" class="header-anchor">#</a> <code>font-style</code></h4> <ul><li><code>font-style:normal</code></li> <li><code>font-style:italic</code>，使用当前字体的斜体</li> <li><code>font-style:oblique</code>，单纯让文字倾斜</li></ul> <h4 id="font-variant"><a href="#font-variant" aria-hidden="true" class="header-anchor">#</a> <code>font-variant</code></h4> <h4 id="font属性"><a href="#font属性" aria-hidden="true" class="header-anchor">#</a> <code>font</code>属性</h4> <h4 id="缩写的font属性"><a href="#缩写的font属性" aria-hidden="true" class="header-anchor">#</a> 缩写的<code>font</code>属性</h4> <p>完整语法：<code>[font-style||font-variant||font-weight]?font-size[/line-height]?font-family</code>，（<code>font-size</code>和<code>font-family</code>是必需项）。</p> <p><code>font</code>缩写会破坏部分属性的继承性，必须要带上<code>font-family</code>。利用<code>@font face</code>规则将字体列表重定义为一个字体。</p> <h4 id="使用关键字值得font属性"><a href="#使用关键字值得font属性" aria-hidden="true" class="header-anchor">#</a> 使用关键字值得<code>font</code>属性</h4> <p><code>font</code>属性支持关键字属性值，语法：<code>font:caption|icon|menu|message-box|small-caption|status-bar</code></p> <ul><li><code>caption</code>：活动窗口标题栏使用的字体</li> <li><code>icon</code>：包含图标内容所使用的字体，如所有文件夹名称、文件名称、磁盘名称，浏览器窗口标题所使用的字体</li> <li><code>menu</code>：菜单使用的字体，如文件夹字体</li> <li><code>message-box</code>：消息盒里面使用的字体</li> <li><code>small-caption</code>：调色板标题所使用的字体</li> <li><code>status-bar</code>：窗体状态栏使用的字体</li></ul> <p>使用关键字作为属性值必须是独立的，不能添加<code>font-family</code>或<code>font-size</code>等。</p> <h4 id="font关键字属性值的应用价值"><a href="#font关键字属性值的应用价值" aria-hidden="true" class="header-anchor">#</a> <code>font</code>关键字属性值的应用价值</h4> <div class="language- extra-class"><pre class="language-text"><code>//推荐使用
html {font: menu;}
body {font-size: 16px;}

html {font: small-caption;}
body {font-size: 16px;}

html {font: status-bar;}
body {font-size: 16px;}
</code></pre></div><h3 id="font-face规则"><a href="#font-face规则" aria-hidden="true" class="header-anchor">#</a> <code>@font face</code>规则</h3> <h4 id="font-face的本质是变量"><a href="#font-face的本质是变量" aria-hidden="true" class="header-anchor">#</a> <code>@font face</code>的本质是变量</h4> <p><code>@font face</code>的本质上就是一个定义字体或字体集的变量，包括字体重命名、默认字体样式设置等。</p> <p><code>@font face</code>规则支持的CSS属性有<code>font-family</code>、<code>src</code>、<code>font-style</code>、<code>font-weight</code>、<code>unicode-range</code>、<code>font-variant</code>、<code>font-stretch</code>和<code>font-feature-settings</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>@font-face {
    font-family: 'example';
    src: url(&quot;example.ttf&quot;);
    font-style: normal;
    font-weight: normal;
    unicode-range: U+0025-00FF;
    font-variant: small-caps;//忽略
    font-stretch: expanded;//忽略
    font-feature-settings: &quot;ligal&quot; on;//忽略
}
</code></pre></div><p><strong>1. font-family</strong></p> <div class="language- extra-class"><pre class="language-text"><code>@font-face {
    font-family: '$';
    src: url(&quot;example.ttf&quot;);
}
</code></pre></div><p><strong>2. src</strong></p> <p>如果是使用系统字体，则使用<code>local()</code>功能符；如果使用外链字体，则使用<code>url()</code>功能符。</p> <div class="language- extra-class"><pre class="language-text"><code>@font-face {
    font-family: ICON;
    src: url(&quot;icon.eot&quot;) format('eot');
    src: url(&quot;icon.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;),
    url(&quot;icon.woff2&quot;) format(&quot;woff2&quot;),
    url(&quot;icon.woff&quot;) format(&quot;woff&quot;),
    url(&quot;icon.ttf&quot;) format(&quot;truetype&quot;),
    url(&quot;icon.svg#icon&quot;) format(&quot;svg&quot;);
    font-style: normal;
    font-weight: normal;
}
</code></pre></div><ul><li><code>eot</code>格式是IE私有的。（<strong>舍弃</strong>）</li> <li><code>woff</code>是专门为Web开发而设计的字体格式。（<strong>次优先使用</strong>）</li> <li><code>woff2</code>是比<code>woff</code>尺寸更小的字体，是Web开发首选字体。（<strong>优先使用</strong>）</li> <li><code>ttf</code>格式作为系统安装字体比较多。（<strong>舍弃</strong>）</li></ul> <p><strong>推荐使用方法</strong>：</p> <div class="language- extra-class"><pre class="language-text"><code>@font-face {
    font-family: ICON;
    src: url(&quot;icon.eot&quot;) format('eot');
    src: local('☺'),
    url(&quot;icon.woff2&quot;) format(&quot;woff2&quot;),
    url(&quot;icon.woff&quot;) format(&quot;woff&quot;),
    url(&quot;icon.ttf&quot;) format(&quot;truetype&quot;);
}
</code></pre></div><p><strong>3. font-style</strong></p> <p><strong>4. font-weight</strong></p> <p><strong>5. unicode-range</strong></p> <p><code>unicode-range</code>的作用是可以让特定的字符或特定范围的字符使用指定的字体。</p> <h4 id="font-face与字体图标技术"><a href="#font-face与字体图标技术" aria-hidden="true" class="header-anchor">#</a> <code>@font face</code>与字体图标技术</h4> <div class="language- extra-class"><pre class="language-text"><code>.icon {
    font-family: ICON;
}

.icon-microphone:before {
    content: '\1f3a4';
}
</code></pre></div><h3 id="文本的控制"><a href="#文本的控制" aria-hidden="true" class="header-anchor">#</a> 文本的控制</h3> <h4 id="text-indent与内联元素缩进"><a href="#text-indent与内联元素缩进" aria-hidden="true" class="header-anchor">#</a> <code>text-indent</code>与内联元素缩进</h4> <p><code>text-indent</code>负值隐藏文本内容。</p> <ol><li><code>text-indent</code>仅对第一行内联盒子内容有效；</li> <li>非替换元素以外的<code>display</code>计算值为<code>inline</code>的内联元素设置<code>text-indent</code>值无效，如果计算值是<code>inline-block/inline-table</code>则会生效。因此，如果父级块状元素设置了<code>text-indent</code>属性值，子<code>inline-block/inline-table</code>需要设置<code>text-indent:0</code>重置。</li> <li><code>input</code>标签按钮<code>text-indent</code>值无效。</li> <li><code>button</code>标签按钮<code>text-indent</code>值有效，但存在兼容性问题。</li> <li><code>input</code>和<code>textarea</code>输入框的<code>text-indent</code>在低版本IE下有兼容性问题。</li></ol> <h4 id="letter-spacing与字符间距"><a href="#letter-spacing与字符间距" aria-hidden="true" class="header-anchor">#</a> <code>letter-spacing</code>与字符间距</h4> <p><code>letter-spacing</code>特性：</p> <ol><li>继承性；</li> <li>默认值是<code>normal</code>不是<code>0</code>。</li> <li>支持负值，且值足够大时会让字符形成重叠，甚至反向排列。</li> <li>第一行都会保留至少一个字符。</li> <li>支持小数值。</li> <li>暂时不支持百分比值。</li></ol> <h4 id="word-spacing与单词间距"><a href="#word-spacing与单词间距" aria-hidden="true" class="header-anchor">#</a> <code>word-spacing</code>与单词间距</h4> <p><code>word-spacing</code>和<code>letter-spacing</code>共同特性：</p> <ol><li>具有继承性；</li> <li>默认值都是<code>normal</code>。</li> <li>都支持负值，都可以让字符重叠，不适合使用<code>word-spacing</code>来清除空白间隙。</li> <li>都支持小数值。</li> <li>间隔算法都会受到<code>text-align:jusitify</code>两端对齐的影响。</li></ol> <p>两者差异：</p> <p><code>letter-spacing</code>作用域所有字符，<code>word-spacing</code>仅作用于空格字符（增加空格的间隙宽度）。</p> <h4 id="了解word-break和word-wrap的区别"><a href="#了解word-break和word-wrap的区别" aria-hidden="true" class="header-anchor">#</a> 了解<code>word-break</code>和<code>word-wrap</code>的区别</h4> <p><code>word-break</code>属性语法：</p> <ul><li><code>word-break:normal</code>：</li> <li><code>word-break:break-all</code>：允许任意非CJK（Chinese/Japanese/Korean）文本间的单词断行</li> <li><code>word-break:keep-all</code>：不允许CJK文本中的单词换行，只能在半角空格或连字符处换行。实际上和<code>normal</code>一致。移动端不适合使用这个属性值。</li></ul> <p><code>word-wrap</code>语法：</p> <ul><li><code>word-wrap:normal</code>：正常的换行规则</li> <li><code>word-wrap:break-word</code>：一行单词中没有换行点时换行，CSS3中名称<code>overflow-wrap</code></li></ul> <p><code>word-break:break-all</code>的作用是所有的都换行，而<code>word-wrap:break-word</code>则是如果这一行文字有了可换行的点（如空格或CJK等），就在这些换行点换行。</p> <h3 id="white-space与换行和空格的控制"><a href="#white-space与换行和空格的控制" aria-hidden="true" class="header-anchor">#</a> <code>white-space</code>与换行和空格的控制</h3> <p><strong>1. white-space的处理模型</strong></p> <p><code>white-space</code>属性声明了如何处理元素内的空白字符，包括<strong>空格键</strong><code>Space</code>、<strong>回车键</strong><code>Enter</code>、<strong>制表符</strong><code>Tab</code>产生的空白。<code>white-space</code>可以决定图文内容是否在一行显示（回车键是否生效），是否显示大段连续空白（空格是否生效）等。</p> <p>其属性值包括：</p> <ul><li><code>normal</code>：合并空白字符和换行符。</li> <li><code>pre</code>：空白字符不合并，并且内容只在有换行符的地方换行。</li> <li><code>nowrap</code>：和<code>normal</code>一样会合并空白字符，但不允许文本环绕。</li> <li><code>pre-wrap</code>：和<code>pre</code>一样，但允许文本环绕。</li> <li><code>pre-line</code>：合并空白字符，但只在有换行符的地方换行允许文本环绕。</li></ul> <p><code>white-space</code>的功能有3个维度，分别是：<strong>是否合并空白字符</strong>、<strong>是否合并换行符</strong>、<strong>文本是否自动换行</strong>。</p> <h4 id="white-space不同属性值功能示意"><a href="#white-space不同属性值功能示意" aria-hidden="true" class="header-anchor">#</a> <strong><code>white-space</code>不同属性值功能示意</strong></h4> <p>| 属性 | 换行 | 空格和制表 | 文本环绕 | | ---- | | <code>normal</code> | 合并 | 合并 |环绕| | <code>nowrap</code> | 合并 | 合并 |不环绕| | <code>pre</code> | 保留 | 保留 |不环绕| | <code>pre-wrap</code> | 保留 | 保留 |环绕| | <code>pre-line</code> | 保留 | 合并 |环绕|</p> <p><strong>2. white-space与最大可用宽度</strong></p> <p>当<code>white-space</code>设置为<code>nowrap</code>时，元素的宽度表现为<strong>最大可用宽度</strong>，换行符和一些空格全部合并，文本一行显示。</p> <ol><li><strong>包含块尺寸大小处理</strong>。绝对定位和<code>inline-block</code>元素都具有包裹性，当文本内容宽度超过包含块宽度时，就会发生文本环绕现象。</li> <li><strong>单行文字溢出...效果</strong>。<code>text-overflow:ellipsis;</code>文字内容超出打点效果离不开<code>white-space:nowrap;</code>声明。</li> <li><strong>水平列表切换效果</strong>。如果列表的数目是不固定的，使用<code>white-space:nowrap;</code>使列表一行显示。</li></ol> <h3 id="text-align与元素对齐"><a href="#text-align与元素对齐" aria-hidden="true" class="header-anchor">#</a> <code>text-align</code>与元素对齐</h3> <p><code>text-align:justify</code>想要实现两端对齐布局效果，需要满足两点：一是<strong>有分隔点</strong>，如空格；二是<strong>要超过一行</strong>，此时不是最后一行内容会两端对齐。</p> <p><code>text-align-last</code>属性，可以规定最后一行内联内容的排列方式。</p> <div class="language- extra-class"><pre class="language-text"><code>.justify {
    text-align-last: justify;
}
</code></pre></div><p>这个方法存在兼容性问题。</p> <h3 id="如何解决text-decoration下划线和文本重叠的问题"><a href="#如何解决text-decoration下划线和文本重叠的问题" aria-hidden="true" class="header-anchor">#</a> 如何解决<code>text-decoration</code>下划线和文本重叠的问题</h3> <p>对于纯内联元素，垂直方向的<code>padding</code>属性和<code>border</code>属性对原来的布局定位等没有任何影响。</p> <blockquote><p>使用<code>border-bottom</code>模拟<code>text-decoration</code>下划线解决文本重叠的问题</p></blockquote> <h3 id="text-transform字符大小写"><a href="#text-transform字符大小写" aria-hidden="true" class="header-anchor">#</a> <code>text-transform</code>字符大小写</h3> <p><code>text-transform</code>是为英文字符设计，<strong>全大写text-transform:uppercase</strong>，<strong>全小写text-transform:lowercase</strong></p> <p><strong>1. 场景一：身份证输入</strong></p> <p><strong>2. 场景二：验证码输入</strong></p> <h3 id="了解-first-letter-first-line伪元素"><a href="#了解-first-letter-first-line伪元素" aria-hidden="true" class="header-anchor">#</a> 了解<code>:first-letter/:first-line</code>伪元素</h3> <h3 id="深入-first-letter伪元素及其实例"><a href="#深入-first-letter伪元素及其实例" aria-hidden="true" class="header-anchor">#</a> 深入<code>:first-letter</code>伪元素及其实例</h3> <h4 id="_1-first-letter伪元素生效的前提"><a href="#_1-first-letter伪元素生效的前提" aria-hidden="true" class="header-anchor">#</a> <strong>1. ::first-letter伪元素生效的前提</strong></h4> <ul><li>元素的<code>display</code>计算值必须是<code>block</code>、<code>inline-block</code>、<code>list-item</code>、<code>table-cell/table-caption</code>，其他值没有用。</li> <li>可以直接作为伪元素的字符是数字、英文字母、中文、<code>$</code>、一些运算符，以及一些“空格”。</li> <li>字符前面不能有图片或<code>inline-block/inline-table</code>之类的元素存在。</li></ul> <h5 id="_2-first-letter伪元素可以生效的css属性"><a href="#_2-first-letter伪元素可以生效的css属性" aria-hidden="true" class="header-anchor">#</a> <strong>2. ::first-letter伪元素可以生效的CSS属性</strong></h5> <p>字符被选做<code>::first-letter</code>伪元素，只有一部分有效：</p> <ul><li>所有字体相关属性：<code>font</code>、<code>font-style</code>、<code>font-variant</code>、<code>font-weight</code>、<code>font-size</code>、<code>line-height</code>和<code>font-family</code>。</li> <li>所有背景相关属性：<code>background-color</code>、<code>background-image</code>、<code>background-position</code>、<code>background-repeat</code>、<code>background-size</code>和<code>background-attachment</code>。</li> <li>所有<code>margin</code>相关属性：<code>margin</code>、<code>margin-top/right/bottom/left</code>。</li> <li>所有<code>padding</code>相关属性：<code>padding</code>、<code>padding-top/right/bottom/left</code>。</li> <li>所有<code>border</code>相关属性：<code>border</code>、<code>border-style</code>、<code>border-color</code>、<code>border-width</code>。</li> <li><code>color</code>属性。</li> <li><code>text-decoration</code>、<code>text-transform</code>、<code>letter-spacing</code>、<code>word-spacing</code>、<code>line-height</code>、<code>float</code>和<code>vertical-align</code>（只有当<code>float:none</code>时）等属性。</li></ul> <p><strong>3. ::first-letter伪元素特点</strong></p> <ol><li><p>支持部分<code>display</code>属性值标签嵌套。<code>::first-letter</code>伪元素获取可以跨标签，不仅能选择匿名内联盒子，还能透过层层标签进行选择。</p> <ul><li><code>display</code>值是<code>inline</code>、<code>block</code>、<code>table</code>、<code>table-row</code>、<code>table-caption</code>、<code>table-cell</code>、<code>list-item</code>有效。</li> <li><code>inline-block/inline-table</code>无效。</li> <li><code>display:flex</code>直接选择下一行的字符内容。</li></ul></li> <li><p>颜色等权重总是多了一层。<code>::first-letter</code>伪元素作为子元素存在，对于<code>color</code>继承属性，子元素的CSS设置一定比父元素的级别要高，即使使用了<code>!important</code>，<strong>子元素会先继承，然后再应用自身设置</strong>。</p> <div class="language- extra-class"><pre class="language-text"><code> p:first-letter {
     color: #cd0000; /*第一个字符的颜色是red*/
 }
 
 p &gt; span {
     color: blue !important;
 }
 &lt;p&gt;&lt;span&gt;第一个&lt;/span&gt;字符会不会变成红色？&lt;/p&gt;
</code></pre></div></li></ol> <p><strong>4. ::first-letter伪元素实际应用</strong></p> <div class="language- extra-class"><pre class="language-text"><code> &lt;p class=&quot;price&quot;&gt;￥399&lt;/p&gt;
 .price:first-letter {
     margin-right: 5px;
     font-size: xx-large;
     vertical-align: -2px;
 }
 `:first-line`伪元素 
 - 只能作用在块级元素上`block/inline-block/list-item/table-cell/table-caption`
 - 仅支持部分CSS属性
 - 所有字体相关属性
 - `color`属性
 - 所有背景相关属性
 - `text-decoration`、`text-transfor`、`letter-spacing`、`word-spacing`、`line-height`和`vertical-align`
 - 支持标签嵌套。不支持`table`属性
 
</code></pre></div><h2 id="元素的修饰与美化"><a href="#元素的修饰与美化" aria-hidden="true" class="header-anchor">#</a> 元素的修饰与美化</h2> <h3 id="color"><a href="#color" aria-hidden="true" class="header-anchor">#</a> <code>color</code></h3> <h3 id="颜色关键字"><a href="#颜色关键字" aria-hidden="true" class="header-anchor">#</a> 颜色关键字</h3> <h3 id="不支持的transparent关键字"><a href="#不支持的transparent关键字" aria-hidden="true" class="header-anchor">#</a> 不支持的<code>transparent</code>关键字</h3> <p><code>color:transparent</code>从IE9才开始支持。</p> <h3 id="不支持的currentcolor变量"><a href="#不支持的currentcolor变量" aria-hidden="true" class="header-anchor">#</a> 不支持的<code>currentColor</code>变量</h3> <p><code>currentColor</code>变量可以使用<code>color</code>计算值。</p> <h3 id="不支持的rgba颜色和hsla颜色"><a href="#不支持的rgba颜色和hsla颜色" aria-hidden="true" class="header-anchor">#</a> 不支持的<code>rgba</code>颜色和<code>hsla</code>颜色</h3> <p><code>color</code>属性支持十六进制颜色、<code>rgb</code>颜色。<code>rgb</code>除了支持数值颜色，还支持百分比<code>rgb</code>颜色，数值格式只能是整数，不能是小数。</p> <p><code>color</code>属性不支持<code>hsl</code>颜色、<code>rgba</code>颜色和<code>hsla</code>颜色。</p> <p><strong>hsl颜色：</strong></p> <ul><li><code>h</code>表示色调<code>hue</code>，取值<code>0~360</code>；</li> <li><code>s</code>表示饱和度，取值<code>0~100%</code>，饱和度越高颜色越亮；</li> <li><code>l</code>表示亮度，取值<code>0~100%</code>，<code>100%</code>是白色，<code>50%</code>是正常亮度，<code>0%</code>是黑色。</li></ul> <h3 id="支持却鸡肋的系统颜色"><a href="#支持却鸡肋的系统颜色" aria-hidden="true" class="header-anchor">#</a> 支持却鸡肋的系统颜色</h3> <h3 id="background"><a href="#background" aria-hidden="true" class="header-anchor">#</a> <code>background</code></h3> <ul><li><code>background-image:none</code></li> <li><code>background-position:0% 0%</code></li> <li><code>background-repeat:repeat</code></li> <li><code>background-attachment:scroll</code></li> <li><code>background-color:transparent</code></li></ul> <p>IE9+浏览器：</p> <ul><li><code>background-size:auto auto</code></li> <li><code>background-origin:padding-box</code></li> <li><code>background-clip:border-box</code></li></ul> <h3 id="隐藏元素的background-image到底加不加载"><a href="#隐藏元素的background-image到底加不加载" aria-hidden="true" class="header-anchor">#</a> 隐藏元素的<code>background-image</code>到底加不加载</h3> <p>IE8浏览器支持<code>base64</code>图片，包括在<code>background-image</code>属性中使用，可以节约网络请求。<code>base64</code>图片的渲染性能不高，大尺寸图片慎用。</p> <h3 id="与众不同的background-position百分比计算方式"><a href="#与众不同的background-position百分比计算方式" aria-hidden="true" class="header-anchor">#</a> 与众不同的<code>background-position</code>百分比计算方式</h3> <p>如果缺省关键字，则会认为是<code>center</code>，<code>background-position:top center</code>=<code>background-position:top</code>。</p> <p><code>background-position:right 40px bottom 20px</code>表示距离右边缘<code>40px</code>，距离下边缘<code>20px</code>。</p> <p><code>position</code>百分比值计算公式：</p> <div class="language- extra-class"><pre class="language-text"><code>positionX`=（容器宽度 - 图片宽度）*precentX positionY=（容器高度 - 图片高度）*`precentY
</code></pre></div><ul><li>（容器宽度 - 图片宽度）×（<code>-50%</code>）的结果是一个<strong>正值</strong>。</li> <li>（容器高度 - 图片高度）×（<code>-50%</code>）的结果是一个<strong>正值</strong>。</li></ul> <p>最终表现图片定位在容器内。</p> <h3 id="background-repeat与渲染性能"><a href="#background-repeat与渲染性能" aria-hidden="true" class="header-anchor">#</a> <code>background-repeat</code>与渲染性能</h3> <h3 id="外强中干的background-attachment-fixed"><a href="#外强中干的background-attachment-fixed" aria-hidden="true" class="header-anchor">#</a> 外强中干的<code>background-attachment:fixed</code></h3> <p><code>background-attachment:fixed</code>只能局限在窗体背景图使用上。</p> <h3 id="background-color背景色永远是最低的"><a href="#background-color背景色永远是最低的" aria-hidden="true" class="header-anchor">#</a> <code>background-color</code>背景色永远是最低的</h3> <h3 id="利用多背景的属性hack小技巧"><a href="#利用多背景的属性hack小技巧" aria-hidden="true" class="header-anchor">#</a> 利用多背景的属性<strong>hack</strong>小技巧</h3> <div class="language- extra-class"><pre class="language-text"><code>.bg {
    background: url(&quot;icon.png&quot;);
    background: url(&quot;icon.svg&quot;), none;
}
</code></pre></div><h3 id="渐变背景和rgba背景色的兼容处理"><a href="#渐变背景和rgba背景色的兼容处理" aria-hidden="true" class="header-anchor">#</a> 渐变背景和<code>rgba</code>背景色的兼容处理</h3> <p><strong>背景渐变，使用IE私有的渐变滤镜实现兼容</strong></p> <div class="language- extra-class"><pre class="language-text"><code>filter: progid:DXImageTransform.Microsoft.
gradient(startcolorstr=red, endcolorstr=blue, gradientType=1);
</code></pre></div><ul><li><code>gradientType=1</code>代表横向渐变</li> <li><code>gradientType=0</code>代表纵向渐变</li> <li><code>startcolorstr</code>代表渐变起始颜色</li></ul> <p>除了使用颜色关键色，还可以使用十六进制颜色值。</p> <blockquote><p>将<code>0~1</code>的CSS3标准透明度值转换成十六进制。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>Math.round(256 * opacity).toString(16);
</code></pre></div><blockquote><p>实现一个<code>100%</code>红色到<code>50%</code>透明度蓝色垂直渐变。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>.gradient {
    filter: progid:DXImageTransform.Microsoft.
    gradient(startcolorstr=#FFFF0000, endcolorstr=#7F0000FF, gradientType=0);
    background: linear-gradient(to bottom, red, rgba(0, 0, 255, .5));
}
.bgcolor {
    background: rgba(0, 0, 0, .5);
    filter: progid:DXImageTransform.Microsoft.
    gradient(startcolorstr=#7F000000, endcolorstr=#7F000000);
}

:root .bgcolor {
    filter: none;
}
</code></pre></div><h2 id="元素的显示与隐藏"><a href="#元素的显示与隐藏" aria-hidden="true" class="header-anchor">#</a> 元素的显示与隐藏</h2> <p>使用CSS让元素不可见的方法，<strong>剪裁</strong>、<strong>定位到屏幕外</strong>、<strong>明度变化</strong>等。</p> <ul><li><p>元素不可见，同时不占据空间，辅助设备无法访问，同时不渲染，可以使用<code>script</code>标签隐藏。</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;script type=&quot;text/html&quot;&gt;
    &lt;img src=&quot;1.jpg&quot;&gt;
    &lt;textarea style=&quot;display: none;&quot;&gt;
        &lt;img src=&quot;2.jpg&quot;&gt;
    &lt;/textarea&gt;
&lt;/script&gt;
</code></pre></div></li></ul> <p><code>script</code>标签隐藏内容获取使用<code>script.innerHTML</code>，<code>textarea</code>使用<code>textarea.value</code>。</p> <ul><li><p>元素不可见，同时不占据空间，辅助设备无法访问，但资源有加载，DOM可访问，则可以直接使用<code>display:none</code>隐藏。</p></li> <li><p>元素不可见，同时不占据空间，辅助设备无法访问，但显示隐藏时可以有<code>transition</code>淡入淡出效果。</p> <div class="language- extra-class"><pre class="language-text"><code>.hidden {
    position: absolute;
    visibility: hidden;
}
</code></pre></div></li> <li><p>元素不可见，不能点击，辅助设备无法访问，但占据空间保留，可以使用<code>visibility:hidden</code>隐藏。</p></li> <li><p>元素不可见，不能点击，不占据空间，但键盘可访问，可以使用<code>clip</code>剪裁隐藏。</p> <div class="language- extra-class"><pre class="language-text"><code>.clip {
    position: absolute;
    clip: rect(0 0 0 0);
}

.out {
    position: relative;
    left: -999em;
}
</code></pre></div></li> <li><p>元素不可见，不能点击，但占据空间，且键盘可访问，可以使用<code>relative</code>隐藏。如果和层叠上下文之间存在设置了背景色的父元素，也可以使用更友好的<code>z-index</code>负值隐藏。</p> <div class="language- extra-class"><pre class="language-text"><code>.lower {
    position: relative;
    z-index: -1;
}
</code></pre></div></li> <li><p>元素不可见，但可以点击，而且不占据空间，可以使用透明度。</p> <div class="language- extra-class"><pre class="language-text"><code>.opacity {
    position: absolute;
    opacity: 0;
    filter: Alpha(opacity=0);
}
</code></pre></div></li> <li><p>元素不可见，但位置保留，可以点击，则直接让透明度为<code>0</code>。</p> <div class="language- extra-class"><pre class="language-text"><code>.opacity {
   opacity: 0;
   filter: Alpha(opacity=0);
}
</code></pre></div></li></ul> <h3 id="display与元素的显示-隐藏"><a href="#display与元素的显示-隐藏" aria-hidden="true" class="header-anchor">#</a> <code>display</code>与元素的显示/隐藏</h3> <h3 id="visibility与元素的显示-隐藏"><a href="#visibility与元素的显示-隐藏" aria-hidden="true" class="header-anchor">#</a> <code>visibility</code>与元素的显示/隐藏</h3> <h4 id="不仅仅是保留空间"><a href="#不仅仅是保留空间" aria-hidden="true" class="header-anchor">#</a> 不仅仅是保留空间</h4> <p><strong>1. visibility的继承性</strong></p> <p>父元素设置<code>visibility:hidden</code>，子元素也会不可见，继承了父元素属性值，但是，如果子元素设置了<code>visibility:visible</code>，则子元素又会显示出来。</p> <p><strong>2. visibility与CSS计数器</strong></p> <p><code>visibility:hidden</code>不会影响计数器的计数，但<code>display:none</code>就会。</p> <p><strong>3. visibility与transition</strong></p> <p><code>transition</code>可以延时执行，和<code>visibility</code>配合可以使用CSS实现<code>hover</code>延时显示效果。</p> <ol><li>普通元素的<code>title</code>属性不会被朗读，除非辅以按钮等空间元素，设置了<code>role=&quot;button&quot;</code>才可以朗读。</li> <li><code>visibility:hidden</code>元素不会被朗读。</li></ol> <h4 id="了解visibility-collapse"><a href="#了解visibility-collapse" aria-hidden="true" class="header-anchor">#</a> 了解<code>visibility:collapse</code></h4> <h2 id="用户界面样式"><a href="#用户界面样式" aria-hidden="true" class="header-anchor">#</a> 用户界面样式</h2> <h3 id="和border形似的outline属性"><a href="#和border形似的outline属性" aria-hidden="true" class="header-anchor">#</a> 和<code>border</code>形似的<code>outline</code>属性</h3> <p><code>outline</code>表示元素的轮廓，语法和<code>border</code>属性类似，分<strong>宽度</strong>、<strong>类型</strong>、<strong>颜色</strong>，支持的关键字和属性值和<code>border</code>属性一模一样。</p> <div class="language- extra-class"><pre class="language-text"><code>.outline {
    outline: 1px solid #ccc;
}
</code></pre></div><h3 id="绝不可以在全局设置outline-0-none"><a href="#绝不可以在全局设置outline-0-none" aria-hidden="true" class="header-anchor">#</a> 绝不可以在全局设置<code>outline:0 none</code></h3> <h3 id="真正不占据空间的outline及其应用"><a href="#真正不占据空间的outline及其应用" aria-hidden="true" class="header-anchor">#</a> 真正不占据空间的<code>outline</code>及其应用</h3> <p><strong>1. 案例一：头像剪裁的矩形镂空效果</strong></p> <p><strong>2. 案例二：自动填满屏幕剩余空间的应用技巧</strong></p> <h3 id="光标属性cursor"><a href="#光标属性cursor" aria-hidden="true" class="header-anchor">#</a> 光标属性<code>cursor</code></h3> <h4 id="琳琅满目的cursor属性值"><a href="#琳琅满目的cursor属性值" aria-hidden="true" class="header-anchor">#</a> 琳琅满目的<code>cursor</code>属性值</h4> <p><strong>1. 常规</strong></p> <ul><li><p><code>cursor:auto</code>：<code>cursor</code>默认值。</p></li> <li><div class="language- extra-class"><pre class="language-text"><code>cursor:default
</code></pre></div><p>：系统默认光标形状。</p> <ul><li>模拟按钮的禁用效果，需要把<code>cursor:pointer</code>还原成<code>cursor:default</code></li></ul></li> <li><p><code>cursor:none</code>：光标隐藏</p></li></ul> <p><strong>2. 链接和状态</strong></p> <ul><li><code>cursor:pointer</code>：</li> <li><code>cursor:help</code>：帮助，光标头上带个问好</li> <li><code>cursor:progress</code>：进行中</li> <li><code>cursor:wait</code>：不推荐使用</li> <li><code>cursor:context-menu</code>：上下文菜单</li></ul> <p><strong>3. 选择</strong></p> <ul><li><code>cursor:text</code>：文字可被选中</li> <li><code>cursor:vertical-text</code>：文字可以垂直居中</li> <li><code>cursor:crosshair</code>：十字光标</li> <li><code>cursor:cell</code>：单元格选框</li></ul> <p><strong>4. 拖曳</strong></p> <ul><li><code>cursor:move</code>：元素可移动</li> <li><code>cursor:copy</code>：元素可复制</li> <li><code>cursor:alias</code>：元素可以创建别名或快捷方式</li> <li><code>cursor:no-drop</code>：当前元素放开到当前位置是不允许的</li> <li><code>cursor:not-allowed</code>：当前行为禁止</li></ul> <p><strong>5. 滚动</strong></p> <ul><li><code>cursor:all-scroll</code>：上下左右都可以滚动</li></ul> <p><strong>6. 拉伸</strong></p> <ul><li><code>cursor:col-resize</code>：移动垂直线条</li> <li><code>cursor:row-resize</code>：移动水平线条</li></ul> <p><strong>1. 单向拉伸</strong></p> <ul><li><code>cursor:n-resize</code>：朝上的单箭头</li> <li><code>cursor:e-resize</code>：朝右的单箭头</li> <li><code>cursor:s-resize</code>：朝下的单箭头</li> <li><code>cursor:w-resize</code>：朝左的单箭头</li> <li><code>cursor:ne-resize</code>：朝右上角的单箭头</li> <li><code>cursor:nw-resize</code>：朝左上角的单箭头</li> <li><code>cursor:se-resize</code>：朝右下角的单箭头</li> <li><code>cursor:sw-resize</code>：朝左下角的单箭头</li></ul> <p><strong>2.双向拉伸</strong></p> <ul><li><code>cursor:ew-resize</code>：</li> <li><code>cursor:ns-resize</code>：</li> <li><code>cursor:nesw-resize</code>：</li> <li><code>cursor:nwse-resize</code>：</li></ul> <p><strong>7. 缩放</strong></p> <ul><li><code>cursor:zoom-in</code>：放大镜</li> <li><code>cursor:zoom-out</code>：缩小镜</li></ul> <p><strong>8. 抓取</strong></p> <ul><li><code>cursor:grab</code>：五指张开</li> <li><code>cursor:grabing</code>：五指收起</li></ul> <h4 id="自定义光标"><a href="#自定义光标" aria-hidden="true" class="header-anchor">#</a> 自定义光标</h4> <p>解决兼容性问题。</p> <h2 id="流向的改变"><a href="#流向的改变" aria-hidden="true" class="header-anchor">#</a> 流向的改变</h2> <h3 id="改变水平流向的direction"><a href="#改变水平流向的direction" aria-hidden="true" class="header-anchor">#</a> 改变水平流向的direction</h3> <h3 id="direction简介"><a href="#direction简介" aria-hidden="true" class="header-anchor">#</a> direction简介</h3> <ul><li><code>direction:ltr;</code> 默认值</li> <li><code>direction:rtl;</code></li></ul> <p><code>direction</code>属性可以改变替换元素或者<code>inline-block/inline-table</code>元素的水平呈现顺序。</p> <ul><li><code>direction</code>属性可以让单行文字溢出用<code>...</code>显示。</li> <li><code>direction</code>属性可以改变表格中列的呈现顺序。</li> <li><code>direction:rtl;</code>可以让<code>text-justify</code>两端对齐元素，最后一行落单的元素右对齐显示。</li></ul> <h3 id="direction的黄金搭档unicode-bidi"><a href="#direction的黄金搭档unicode-bidi" aria-hidden="true" class="header-anchor">#</a> <code>direction</code>的黄金搭档<code>unicode-bidi</code></h3> <p><code>unicode-bidi</code>兼容性比较好的属性：</p> <ul><li><code>unicode-bidi:normal;</code> 默认值</li> <li><code>unicode-bidi:embed;</code></li> <li><code>unicode-bidi:bidi-override;</code></li></ul> <ol><li><code>unicode-bidi:embed;</code>只能作用在内联元素上。<code>embed</code>属性值的字符排序是独立内嵌，不受外部影响。</li> <li><code>embed</code>属性值的作用原理是在元素的开始和结束为止插入特殊字符实现，在元素开始位置添加了一个<code>U+202A</code>字符（<code>direction:ltr</code>）或<code>U+202B</code>字符（<code>direction:rtl</code>），并在该元素结束位置添加一个<code>U+202C</code>字符。</li> <li><code>bidi-override</code>：重写双向排序规则。</li></ol> <h3 id="writing-mode"><a href="#writing-mode" aria-hidden="true" class="header-anchor">#</a> <code>writing-mode</code></h3> <h4 id="writing-mode原来的作用"><a href="#writing-mode原来的作用" aria-hidden="true" class="header-anchor">#</a> <code>writing-mode</code>原来的作用</h4> <p><code>writing-mode</code>用来实现文字竖向呈现。</p> <p><strong>1. writing-mode的语法</strong></p> <p>CSS3语法：</p> <p><strong>关键字</strong></p> <ul><li><code>writing-mode: horizontal-lab</code> 默认值</li> <li><code>writing-mode: vertical-lr</code></li> <li><code>writing-mode: vertical-rl</code></li></ul> <p><strong>全局值</strong></p> <ul><li><code>writing-mode: inherit</code></li> <li><code>writing-mode: initial</code></li> <li><code>writing-mode: unset</code></li></ul> <p>IE关键字：</p> <ul><li><code>lr-tb</code>：内容从左往右、从上往下水平流动，并且下一行水平元素在上一行元素的下面，所有符号都是直立定位。</li> <li><code>rl-tb</code>：内容从右往左、从上往下水平流动，并且下一行水平元素在上一行元素的下面，所有符号都是直立定位。</li> <li><code>tb-rl</code>：内容从上往下、从右往左垂直流动，下一行垂直定位于前一个垂直行的左边，全角符号直立定位，非全角符号顺时针方向<code>90°</code>。</li> <li><code>bt-rl</code>：内容从下往上、从右往左垂直流动，下一行垂直定位于前一个垂直行的左边，全角符号直立定位，非全角符号顺时针方向<code>90°</code>。</li> <li><code>bt-lr</code>：内容从上往下、从左往右垂直流动，下一行垂直行在前一个的左边`。</li> <li><code>tb-lr</code>：内容从下往上、从左往右垂直流动。</li> <li><code>lr-bt</code>：内容从下往上、从左往右水平流动，下一行水平行在前一个的上面`。</li> <li><code>rl-bt</code>：内容从下往上、从右往左水平流动</li></ul> <p><strong>补充说明</strong>：相同的<code>writing-mode</code>属性值不会叠加。</p> <p><strong>2. 需要关注的writing-mode属性值</strong></p> <ul><li><code>writing-mode: lr-tb | tb-rl | tb-lr (IE8+)</code></li> <li><code>writing-mode: horizontal-tb | vertical-rl | vertical-lr</code></li></ul> <h4 id="writing-mode改变了哪些规则"><a href="#writing-mode改变了哪些规则" aria-hidden="true" class="header-anchor">#</a> <code>writing-mode</code>改变了哪些规则</h4> <p><code>writing-mode</code>将页面默认的水平流改为垂直流。</p> <p><strong>1. 水平方向也能margin合并</strong></p> <p><strong>2. 普通块元素可以使用margin:auto实现垂直居中</strong></p> <ol><li>图片元素</li> <li>普通块状元素</li></ol> <p><strong>3. 可以使用text-align:center实现图片垂直居中</strong></p> <p><strong>4. 可以使用text-indent实现文字下沉效果</strong></p> <p><strong>5. 可以实现全兼容的icon fonts图标的旋转效果</strong></p> <p><strong>6. 充分利用高度的高度自适应布局</strong></p> <h4 id="writing-mode和direction的关系"><a href="#writing-mode和direction的关系" aria-hidden="true" class="header-anchor">#</a> <code>writing-mode</code>和<code>direction</code>的关系</h4> <blockquote><p><code>writing-mode</code>、<code>direction</code>和<code>unicode-bidi</code>是CSS中三大可以改变文本布局流向的属性，其中<code>direction</code>和<code>unicode-bidi</code>经常一起使用，也是仅有的两个不受CSS3的<code>all</code>属性影响的CSS属性，基本上就是和内联元素一起使用。</p></blockquote></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/sugarBlog/Product/product-1/p1.html" class="prev">
          产品11
        </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/sugarBlog/assets/js/app.94826577.js" defer></script><script src="/sugarBlog/assets/js/2.baf12719.js" defer></script><script src="/sugarBlog/assets/js/15.33b09ea6.js" defer></script>
  </body>
</html>
